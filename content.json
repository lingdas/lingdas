{"meta":{"title":"lovelves","subtitle":null,"description":"光颖","author":"lovelves","url":"https://lingdas.github.io"},"pages":[{"title":"about","date":"2021-06-12T14:14:36.000Z","updated":"2021-06-10T15:27:41.543Z","comments":false,"path":"about/index.html","permalink":"https://lingdas.github.io/about/index.html","excerpt":"","text":"[lovelves的家] 与&nbsp; lovelves&nbsp; （ 龙傲天 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://lingdas.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"https://lingdas.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"https://lingdas.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"https://lingdas.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"https://lingdas.github.io/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"links/index.html","permalink":"https://lingdas.github.io/links/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"music/index.html","permalink":"https://lingdas.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"https://lingdas.github.io/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"https://lingdas.github.io/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://lingdas.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"https://lingdas.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"hexo的安装使用","slug":"hexo","date":"2021-06-14T01:42:14.000Z","updated":"2021-06-15T15:18:58.531Z","comments":true,"path":"2021/06/14/hexo/","link":"","permalink":"https://lingdas.github.io/2021/06/14/hexo/","excerpt":"","text":"安装hexonpm install hexo-cli -g hexo 使用方法生成hexo 官方的简单主题 hexo init 生成静态页面 hexo g 运行服务 hexo s 部署 npm install hexo-deployer-git --save hexo d","categories":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lingdas.github.io/tags/hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}]},{"title":"SpringIoC和DI注解开发","slug":"02-SpringIoC和DI注解开发","date":"2021-06-14T01:42:14.000Z","updated":"2021-06-15T15:30:14.979Z","comments":true,"path":"2021/06/14/02-SpringIoC和DI注解开发/","link":"","permalink":"https://lingdas.github.io/2021/06/14/02-SpringIoC和DI注解开发/","excerpt":"","text":"1.Spring配置数据源1.1 数据源（连接池）的作用数据源(连接池)是提高程序性能如出现的 事先实例化数据源，初始化部分连接资源 使用连接资源时从数据源中获取 使用完毕后将连接资源归还给数据源 常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等 开发步骤 ①导入数据源的坐标和数据库驱动坐标 ②创建数据源对象 ③设置数据源的基本连接数据 ④使用数据源获取连接资源和归还连接资源 1.2 数据源的手动创建①导入c3p0和druid的坐标 &lt;!-- C3P0连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Druid连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; ①导入mysql数据库驱动坐标 &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt; &lt;/dependency&gt; ②创建C3P0连接池 @Test public void testC3P0() throws Exception { //创建数据源 ComboPooledDataSource dataSource = new ComboPooledDataSource(); //设置数据库连接参数 dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection); } ②创建Druid连接池 @Test public void testDruid() throws Exception { //创建数据源 DruidDataSource dataSource = new DruidDataSource(); //设置数据库连接参数 dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection); } ③提取jdbc.properties配置文件 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/test jdbc.username=root jdbc.password=root ④读取jdbc.properties配置文件创建连接池 @Test public void testC3P0ByProperties() throws Exception { //加载类路径下的jdbc.properties ResourceBundle rb = ResourceBundle.getBundle(&quot;jdbc&quot;); ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(rb.getString(&quot;jdbc.driver&quot;)); dataSource.setJdbcUrl(rb.getString(&quot;jdbc.url&quot;)); dataSource.setUser(rb.getString(&quot;jdbc.username&quot;)); dataSource.setPassword(rb.getString(&quot;jdbc.password&quot;)); Connection connection = dataSource.getConnection(); System.out.println(connection); } 1.3 Spring配置数据源可以将DataSource的创建权交由Spring容器去完成 DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的 DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入 &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; 测试从容器当中获取数据源 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DataSource dataSource = (DataSource) applicationContext.getBean(&quot;dataSource&quot;); Connection connection = dataSource.getConnection(); System.out.println(connection); 1.4 抽取jdbc配置文件applicationContext.xml加载jdbc.properties配置文件获得连接信息。 首先，需要引入context命名空间和约束路径： 命名空间：xmlns:context=”http://www.springframework.org/schema/context&quot; 约束路径：http://www.springframework.org/schema/context​ ​ http://www.springframework.org/schema/context/spring-context.xsd &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/bean&gt; 1.5 知识要点Spring容器加载properties文件 &lt;context:property-placeholder location=&quot;xx.properties&quot;/&gt; &lt;property name=&quot;&quot; value=&quot;${key}&quot;/&gt; 2. Spring注解开发2.1 Spring原始注解Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。 Spring原始注解主要是替代的配置 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 注意： 使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。 &lt;!--注解的组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt; 使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。 //@Component(&quot;userDao&quot;) @Repository(&quot;userDao&quot;) public class UserDaoImpl implements UserDao { @Override public void save() { System.out.println(&quot;save running... ...&quot;); } } 使用@Compont或@Service标识UserServiceImpl需要Spring进行实例化 使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入 //@Component(&quot;userService&quot;) @Service(&quot;userService&quot;) public class UserServiceImpl implements UserService { /*@Autowired @Qualifier(&quot;userDao&quot;)*/ @Resource(name=&quot;userDao&quot;) private UserDao userDao; @Override public void save() { userDao.save(); } } 使用@Value进行字符串的注入 @Repository(&quot;userDao&quot;) public class UserDaoImpl implements UserDao { @Value(&quot;注入普通数据&quot;) private String str; @Value(&quot;${jdbc.driver}&quot;) private String driver; @Override public void save() { System.out.println(str); System.out.println(driver); System.out.println(&quot;save running... ...&quot;); } } 使用@Scope标注Bean的范围 //@Scope(&quot;prototype&quot;) @Scope(&quot;singleton&quot;) public class UserDaoImpl implements UserDao { //此处省略代码 } 使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法 @PostConstruct public void init(){ System.out.println(&quot;初始化方法....&quot;); } @PreDestroy public void destroy(){ System.out.println(&quot;销毁方法.....&quot;); } 2.2 Spring新注解使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下： 非自定义的Bean的配置： 加载properties文件的配置：context:property-placeholder 组件扫描的配置：context:component-scan 引入其他文件： 注解 说明 @Configuration 用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解 @ComponentScan 用于指定 Spring 在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中的 &lt;context:component-scan base-package=”com.itheima”/&gt;一样 @Bean 使用在方法上，标注将该方法的返回值存储到 Spring 容器中 @PropertySource 用于加载.properties 文件中的配置 @Import 用于导入其他配置类 @Configuration @ComponentScan @Import @Configuration @ComponentScan(&quot;com.itheima&quot;) @Import({DataSourceConfiguration.class}) public class SpringConfiguration { } @PropertySource @value @PropertySource(&quot;classpath:jdbc.properties&quot;) public class DataSourceConfiguration { @Value(&quot;${jdbc.driver}&quot;) private String driver; @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String username; @Value(&quot;${jdbc.password}&quot;) private String password; @Bean @Bean(name=&quot;dataSource&quot;) public DataSource getDataSource() throws PropertyVetoException { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource; } 测试加载核心配置类创建Spring容器 @Test public void testAnnoConfiguration() throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfiguration.class); UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;); userService.save(); DataSource dataSource = (DataSource) applicationContext.getBean(&quot;dataSource&quot;); Connection connection = dataSource.getConnection(); System.out.println(connection); } 3. Spring整合Junit3.1 原始Junit测试Spring的问题在测试类中，每个测试方法都有以下两行代码： ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class); 这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。 3.2 上述问题解决思路让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它 将需要进行测试Bean直接在测试类中进行注入 3.3 Spring集成Junit步骤①导入spring集成Junit的坐标 ②使用@Runwith注解替换原来的运行期 ③使用@ContextConfiguration指定配置文件或配置类 ④使用@Autowired注入需要测试的对象 ⑤创建测试方法进行测试 3.4 Spring集成Junit代码实现①导入spring集成Junit的坐标 &lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; ②使用@Runwith注解替换原来的运行期 @RunWith(SpringJUnit4ClassRunner.class) public class SpringJunitTest { } ③使用@ContextConfiguration指定配置文件或配置类 @RunWith(SpringJUnit4ClassRunner.class) //加载spring核心配置文件 //@ContextConfiguration(value = {&quot;classpath:applicationContext.xml&quot;}) //加载spring核心配置类 @ContextConfiguration(classes = {SpringConfiguration.class}) public class SpringJunitTest { } ④使用@Autowired注入需要测试的对象 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = {SpringConfiguration.class}) public class SpringJunitTest { @Autowired private UserService userService; } ⑤创建测试方法进行测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = {SpringConfiguration.class}) public class SpringJunitTest { @Autowired private UserService userService; @Test public void testUserService(){ userService.save(); } } Spring集成Junit步骤 ①导入spring集成Junit的坐标 ②使用@Runwith注解替换原来的运行期 ③使用@ContextConfiguration指定配置文件或配置类 ④使用@Autowired注入需要测试的对象 ⑤创建测试方法进行测试","categories":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://lingdas.github.io/tags/springboot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}]},{"title":"AOP","slug":"AOP","date":"2021-06-14T01:42:14.000Z","updated":"2021-06-15T15:19:11.469Z","comments":true,"path":"2021/06/14/AOP/","link":"","permalink":"https://lingdas.github.io/2021/06/14/AOP/","excerpt":"","text":"1.Spring 的 AOP 简介1.1 什么是 AOPAOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 1.2 AOP 的作用及其优势作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 1.3 AOP 的底层实现实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 1.4 AOP 的动态代理技术常用的动态代理技术 JDK 代理 : 基于接口的动态代理技术 cglib 代理：基于父类的动态代理技术 1.5 JDK 的动态代理①目标类接口 public interface TargetInterface { public void method(); } ②目标类 public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); } } ③动态代理代码 Target target = new Target(); //创建目标对象 //创建代理对象 TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(target.getClass() .getClassLoader(),target.getClass().getInterfaces(),new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;前置增强代码...&quot;); Object invoke = method.invoke(target, args); System.out.println(&quot;后置增强代码...&quot;); return invoke; } } ); ④ 调用代理对象的方法测试 // 测试,当调用接口的任何方法时，代理对象的代码都无序修改 proxy.method(); 1.6 cglib 的动态代理①目标类 public class Target { public void method() { System.out.println(&quot;Target running....&quot;); } } ②动态代理代码 Target target = new Target(); //创建目标对象 Enhancer enhancer = new Enhancer(); //创建增强器 enhancer.setSuperclass(Target.class); //设置父类 enhancer.setCallback(new MethodInterceptor() { //设置回调 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(&quot;前置代码增强....&quot;); Object invoke = method.invoke(target, objects); System.out.println(&quot;后置代码增强....&quot;); return invoke; } }); Target proxy = (Target) enhancer.create(); //创建代理对象 ③调用代理对象的方法测试 //测试,当调用接口的任何方法时，代理对象的代码都无序修改 proxy.method(); 1.7 AOP 相关概念Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。 在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下： Target（目标对象）：代理的目标对象 Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点 Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义 Advice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知 Aspect（切面）：是切入点和通知（引介）的结合 Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入 1.8 AOP 开发明确的事项 1.8 AOP 开发明确的事项 1.8 AOP 开发明确的事项1)需要编写的内容 编写核心业务代码（目标类的目标方法） 编写切面类，切面类中有通知(增强功能方法) 在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合 2）AOP 技术实现的内容Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 3）AOP 底层使用哪种代理方式在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 1.9 知识要点 aop：面向切面编程 aop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理 aop的重点概念： Pointcut（切入点）：被增强的方法 Advice（通知/ 增强）：封装增强业务逻辑的方法 Aspect（切面）：切点+通知 Weaving（织入）：将切点与通知结合的过程 开发明确事项： 谁是切点（切点表达式配置） 谁是通知（切面类中的增强方法） 将切点和通知进行织入配置 2. 基于 XML 的 AOP 开发2.1 快速入门①导入 AOP 相关坐标 ②创建目标接口和目标类（内部有切点） ③创建切面类（内部有增强方法） ④将目标类和切面类的对象创建权交给 spring ⑤在 applicationContext.xml 中配置织入关系 ⑥测试代码 ①导入 AOP 相关坐标 &lt;!--导入spring的context坐标，context依赖aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aspectj的织入 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; ②创建目标接口和目标类（内部有切点） public interface TargetInterface { public void method(); } public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); } } ③创建切面类（内部有增强方法） public class MyAspect { //前置增强方法 public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } } ④将目标类和切面类的对象创建权交给 spring &lt;!--配置目标类--&gt; &lt;bean id=&quot;target&quot; class=&quot;com.itheima.aop.Target&quot;&gt;&lt;/bean&gt; &lt;!--配置切面类--&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;com.itheima.aop.MyAspect&quot;&gt;&lt;/bean&gt; ⑤在 applicationContext.xml 中配置织入关系 导入aop命名空间 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; ⑤在 applicationContext.xml 中配置织入关系 配置切点表达式和前置增强的织入关系 &lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(public void com.itheima.aop.Target.method())&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; ⑥测试代码 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class AopTest { @Autowired private TargetInterface target; @Test public void test1(){ target.method(); } } ⑦测试结果 2.2 XML 配置 AOP 详解1) 切点表达式的写法表达式语法： execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号* 代表任意 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表 例如： execution(public void com.itheima.aop.Target.method()) execution(void com.itheima.aop.Target.*(..)) execution(* com.itheima.aop.*.*(..)) execution(* com.itheima.aop..*.*(..)) execution(* *..*.*(..)) 2) 通知的类型通知的配置语法： &lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式&quot;&gt;&lt;/aop:通知类型&gt; 3) 切点表达式的抽取当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。 &lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.itheima.aop.*.*(..))&quot;/&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 2.3 知识要点 aop织入的配置 &lt;aop:config&gt; &lt;aop:aspect ref=“切面类”&gt; &lt;aop:before method=“通知方法名称” pointcut=“切点表达式&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知 切点表达式的写法： execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 3.基于注解的 AOP 开发3.1 快速入门基于注解的aop开发步骤： ①创建目标接口和目标类（内部有切点） ②创建切面类（内部有增强方法） ③将目标类和切面类的对象创建权交给 spring ④在切面类中使用注解配置织入关系 ⑤在配置文件中开启组件扫描和 AOP 的自动代理 ⑥测试 ①创建目标接口和目标类（内部有切点） public interface TargetInterface { public void method(); } public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); } } ②创建切面类（内部有增强方法) public class MyAspect { //前置增强方法 public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } } ③将目标类和切面类的对象创建权交给 spring @Component(&quot;target&quot;) public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); } } @Component(&quot;myAspect&quot;) public class MyAspect { public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } } ④在切面类中使用注解配置织入关系 @Component(&quot;myAspect&quot;) @Aspect public class MyAspect { @Before(&quot;execution(* com.itheima.aop.*.*(..))&quot;) public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } } ⑤在配置文件中开启组件扫描和 AOP 的自动代理 &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.itheima.aop&quot;/&gt; &lt;!--aop的自动代理--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; ⑥测试代码 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class AopTest { @Autowired private TargetInterface target; @Test public void test1(){ target.method(); } } ⑦测试结果 3.2 注解配置 AOP 详解1) 注解通知的类型通知的配置语法：@通知注解(“切点表达式”) 2) 切点表达式的抽取同 xml配置aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下： @@Component(&quot;myAspect&quot;) @Aspect public class MyAspect { @Before(&quot;MyAspect.myPoint()&quot;) public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } @Pointcut(&quot;execution(* com.itheima.aop.*.*(..))&quot;) public void myPoint(){} } 3.3 知识要点 注解aop开发步骤 ①使用@Aspect标注切面类 ②使用@通知注解标注通知方法 ③在配置文件中配置aop自动代理aop:aspectj-autoproxy/ 通知注解类型","categories":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://lingdas.github.io/tags/springboot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}]},{"title":"SpringIoC&DI","slug":"springboot笔记","date":"2021-06-14T00:46:12.000Z","updated":"2021-06-15T15:32:26.761Z","comments":true,"path":"2021/06/14/springboot笔记/","link":"","permalink":"https://lingdas.github.io/2021/06/14/springboot笔记/","excerpt":"","text":"1. spring概述1.1 Spring是什么（理解）Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。 提供了展现层 SpringMVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架 1.2 Spring发展历程 （了解）Rod Johnson （ Spring 之父） 2017 年9 月份发布了 Spring 的最新版本 Spring5.0通用版（GA） 1.3 Spring的优势（理解）方便解耦，简化开发 AOP 编程的支持 声明式事务的支持 方便程序的测试 1.4 Spring的体系结构（了解） 2. spring快速入门2.1 Spring程序开发步骤①导入 Spring 开发的基本包坐标 ②编写 Dao 接口和实现类 ③创建 Spring 核心配置文件 ④在 Spring 配置文件中配置 UserDaoImpl ⑤使用 Spring 的 API 获得 Bean 实例 2.2 导入Spring开发的基本包坐标&lt;properties&gt; &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.3 编写Dao接口和实现类public interface UserDao { public void save(); } public class UserDaoImpl implements UserDao { @Override public void save() { System.out.println(&quot;UserDao save method running....&quot;); } } 2.4 创建Spring核心配置文件在类路径下（resources）创建applicationContext.xml配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;/beans&gt; 2.5 在Spring配置文件中配置UserDaoImpl&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 2.6 使用Spring的API获得Bean实例@Test public void test1(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); } 3. Spring配置文件3.1 Bean标签基本配置用于配置对象交由Spring 来创建。 默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。 基本属性： id：Bean实例在Spring容器中的唯一标识 class：Bean的全限定名称 3.2 Bean标签范围配置scope:指对象的作用范围，取值如下： 取值范围 说明 singleton 默认值，单例的 prototype 多例的 request WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 request 域中 session WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 session 域中 global session WEB 项目中，应用在 Portlet 环境，如果没有 Portlet 环境那么globalSession 相当于 session 1）当scope的取值为singleton时 ​ Bean的实例化个数：1个 ​ Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例 ​ Bean的生命周期： 对象创建：当应用加载，创建容器时，对象就被创建了 对象运行：只要容器在，对象一直活着 对象销毁：当应用卸载，销毁容器时，对象就被销毁了 2）当scope的取值为prototype时 ​ Bean的实例化个数：多个 ​ Bean的实例化时机：当调用getBean()方法时实例化Bean 对象创建：当使用对象时，创建新的对象实例 对象运行：只要对象在使用中，就一直活着 对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了 3.3 Bean生命周期配置init-method：指定类中的初始化方法名称 destroy-method：指定类中销毁方法名称 3.4 Bean实例化三种方式1） 使用无参构造方法实例化 ​ 它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败 &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; 2） 工厂静态方法实例化 ​ 工厂的静态方法返回Bean实例 public class StaticFactoryBean { public static UserDao createUserDao(){ return new UserDaoImpl(); } } &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.StaticFactoryBean&quot; factory-method=&quot;createUserDao&quot; /&gt; 3） 工厂实例方法实例化 ​ 工厂的非静态方法返回Bean实例 public class DynamicFactoryBean { public UserDao createUserDao(){ return new UserDaoImpl(); } } &lt;bean id=&quot;factoryBean&quot; class=&quot;com.itheima.factory.DynamicFactoryBean&quot;/&gt; &lt;bean id=&quot;userDao&quot; factory-bean=&quot;factoryBean&quot; factory-method=&quot;createUserDao&quot;/&gt; 3.5 Bean的依赖注入入门①创建 UserService，UserService 内部在调用 UserDao的save() 方法 public class UserServiceImpl implements UserService { @Override public void save() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); } } ②将 UserServiceImpl 的创建权交给 Spring &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;/&gt; ③从 Spring 容器中获得 UserService 进行操作 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;); userService.save(); 3.6 Bean的依赖注入概念依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。 在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。 IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。 简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取 3.7 Bean的依赖注入方式①构造方法 ​ 创建有参构造 public class UserServiceImpl implements UserService { @Override public void save() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); } } ​ 配置Spring容器调用有参构造时进行注入 &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; ②set方法 ​ 在UserServiceImpl中添加setUserDao方法 public class UserServiceImpl implements UserService { private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void save() { userDao.save(); } } ​ 配置Spring容器调用set方法进行注入 &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; set方法:P命名空间注入 ​ P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下： ​ 首先，需要引入P命名空间： xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 其次，需要修改注入方式 &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot;/&gt; 3.8 Bean的依赖注入的数据类型上面的操作，都是注入的引用Bean，处了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。 注入数据的三种数据类型 普通数据类型 引用数据类型 集合数据类型 其中引用数据类型，此处就不再赘述了，之前的操作都是对UserDao对象的引用进行注入的，下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。 Bean的依赖注入的数据类型 （1）普通数据类型的注入 public class UserDaoImpl implements UserDao { private String company; private int age; public void setCompany(String company) { this.company = company; } public void setAge(int age) { this.age = age; } public void save() { System.out.println(company+&quot;===&quot;+age); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;company&quot; value=&quot;传智播客&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;&gt;&lt;/property&gt; &lt;/bean&gt; （2）集合数据类型（List）的注入 public class UserDaoImpl implements UserDao { private List&lt;String&gt; strList; public void setStrList(List&lt;String&gt; strList) { this.strList = strList; } public void save() { System.out.println(strList); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;strList&quot;&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; （3）集合数据类型（List）的注入 public class UserDaoImpl implements UserDao { private List&lt;User&gt; userList; public void setUserList(List&lt;User&gt; userList) { this.userList = userList; } public void save() { System.out.println(userList); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;u1&quot; class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean id=&quot;u2&quot; class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;userList&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean class=&quot;com.itheima.domain.User&quot;/&gt; &lt;ref bean=&quot;u1&quot;/&gt; &lt;ref bean=&quot;u2&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; （4）集合数据类型（ Map&lt;String,User&gt; ）的注入 public class UserDaoImpl implements UserDao { private Map&lt;String,User&gt; userMap; public void setUserMap(Map&lt;String, User&gt; userMap) { this.userMap = userMap; } public void save() { System.out.println(userMap); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;u1&quot; class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean id=&quot;u2&quot; class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;userMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;user1&quot; value-ref=&quot;u1&quot;/&gt; &lt;entry key=&quot;user2&quot; value-ref=&quot;u2&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; （5）集合数据类型（Properties）的注入 public class UserDaoImpl implements UserDao { private Properties properties; public void setProperties(Properties properties) { this.properties = properties; } public void save() { System.out.println(properties); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;p1&quot;&gt;aaa&lt;/prop&gt; &lt;prop key=&quot;p2&quot;&gt;bbb&lt;/prop&gt; &lt;prop key=&quot;p3&quot;&gt;ccc&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 3.9 引入其他配置文件（分模块开发）实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载 &lt;import resource=&quot;applicationContext-xxx.xml&quot;/&gt; 4. spring相关API4.1 ApplicationContext的继承体系applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象 4.2 ApplicationContext的实现类1）ClassPathXmlApplicationContext ​ 它是从类的根路径下加载配置文件 推荐使用这种 2）FileSystemXmlApplicationContext ​ 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 3）AnnotationConfigApplicationContext ​ 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 4.3 getBean()方法使用public Object getBean(String name) throws BeansException { assertBeanFactoryActive(); return getBeanFactory().getBean(name); } public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException { assertBeanFactoryActive(); return getBeanFactory().getBean(requiredType); } 其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。 当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错 getBean()方法使用 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService userService1 = (UserService) applicationContext.getBean(&quot;userService&quot;); UserService userService2 = applicationContext.getBean(UserService.class);","categories":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://lingdas.github.io/tags/springboot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}]}]}