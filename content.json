{"meta":{"title":"lovelves","subtitle":null,"description":"光颖","author":"lovelves","url":"https://lingdas.github.io"},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://lingdas.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2021-06-12T14:14:36.000Z","updated":"2021-06-10T15:27:41.000Z","comments":false,"path":"about/index.html","permalink":"https://lingdas.github.io/about/index.html","excerpt":"","text":"[lovelves的家] 与&nbsp; lovelves&nbsp; （ 龙傲天 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"https://lingdas.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"https://lingdas.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"https://lingdas.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"https://lingdas.github.io/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"links/index.html","permalink":"https://lingdas.github.io/links/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"https://lingdas.github.io/tags/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"music/index.html","permalink":"https://lingdas.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"https://lingdas.github.io/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://lingdas.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"https://lingdas.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"springmvc_03","slug":"springmvc-day03","date":"2021-06-15T04:02:56.000Z","updated":"2021-06-16T06:47:42.000Z","comments":true,"path":"2021/06/15/springmvc-day03/","link":"","permalink":"https://lingdas.github.io/2021/06/15/springmvc-day03/","excerpt":"","text":"SpringMVC的文件上传1-SpringMVC的请求-文件上传-客户端表单实现(应用)文件上传客户端表单需要满足： 表单项type=“file” 表单的提交方式是post 表单的enctype属性是多部分表单形式，及enctype=“multipart/form-data” &lt;form action=&quot;${pageContext.request.contextPath}/user/quick22&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 文件1&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; 2-SpringMVC的请求-文件上传-文件上传的原理(理解) 3-SpringMVC的请求-文件上传-单文件上传的代码实现1(应用)添加依赖 &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; 配置多媒体解析器 &lt;!--配置文件上传解析器--&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UYF-8&quot;/&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;500000&quot;/&gt; &lt;/bean&gt; 后台程序 @RequestMapping(value=&quot;/quick22&quot;) @ResponseBody public void save22(String username, MultipartFile uploadFile) throws IOException { System.out.println(username); System.out.println(uploadFile); } 4-SpringMVC的请求-文件上传-单文件上传的代码实现2(应用)完成文件上传 @RequestMapping(value=&quot;/quick22&quot;) @ResponseBody public void save22(String username, MultipartFile uploadFile) throws IOException { System.out.println(username); //获得上传文件的名称 String originalFilename = uploadFile.getOriginalFilename(); uploadFile.transferTo(new File(&quot;C:\\\\upload\\\\&quot;+originalFilename)); } 5-SpringMVC的请求-文件上传-多文件上传的代码实现(应用)多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[]即可 &lt;form action=&quot;${pageContext.request.contextPath}/user/quick23&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 文件1&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br/&gt; 文件2&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; @RequestMapping(value=&quot;/quick23&quot;) @ResponseBody public void save23(String username, MultipartFile[] uploadFile) throws IOException { System.out.println(username); for (MultipartFile multipartFile : uploadFile) { String originalFilename = multipartFile.getOriginalFilename(); multipartFile.transferTo(new File(&quot;C:\\\\upload\\\\&quot;+originalFilename)); } } 6-SpringMVC的请求-知识要点(理解，记忆) SpringMVC的拦截器01-SpringMVC拦截器-拦截器的作用(理解)Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（InterceptorChain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。 02-SpringMVC拦截器-interceptor和filter区别(理解，记忆)关于interceptor和filter的区别，如图所示： 03-SpringMVC拦截器-快速入门(应用)自定义拦截器很简单，只有如下三步： ①创建拦截器类实现HandlerInterceptor接口 ②配置拦截器 ③测试拦截器的拦截效果 编写拦截器： public class MyInterceptor1 implements HandlerInterceptor { //在目标方法执行之前 执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException { System.out.println(&quot;preHandle.....&quot;); } //在目标方法执行之后 视图对象返回之前执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { System.out.println(&quot;postHandle...&quot;); } //在流程都执行完毕后 执行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { System.out.println(&quot;afterCompletion....&quot;); } } 配置：在SpringMVC的配置文件中配置 &lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 编写测试程序测试： 编写Controller,发请求到controller,跳转页面 @Controller public class TargetController { @RequestMapping(&quot;/target&quot;) public ModelAndView show(){ System.out.println(&quot;目标资源执行......&quot;); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;name&quot;,&quot;itcast&quot;); modelAndView.setViewName(&quot;index&quot;); return modelAndView; } } 页面 &lt;html&gt; &lt;body&gt; &lt;h2&gt;Hello World! ${name}&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; 04-SpringMVC拦截器-快速入门详解(应用)拦截器在预处理后什么情况下会执行目标资源，什么情况下不执行目标资源，以及在有多个拦截器的情况下拦截器的执行顺序是什么? 再编写一个拦截器2， public class MyInterceptor2 implements HandlerInterceptor { //在目标方法执行之前 执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException { System.out.println(&quot;preHandle22222.....&quot;); return true; } //在目标方法执行之后 视图对象返回之前执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { System.out.println(&quot;postHandle2222...&quot;); } //在流程都执行完毕后 执行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { System.out.println(&quot;afterCompletion2222....&quot;); } } 配置拦截器2 &lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyInterceptor2&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 结论： 当拦截器的preHandle方法返回true则会执行目标资源，如果返回false则不执行目标资源 多个拦截器情况下，配置在前的先执行，配置在后的后执行 拦截器中的方法执行顺序是：preHandler——-目标资源—-postHandle—- afterCompletion 05-SpringMVC拦截器-知识小结(记忆)拦截器中的方法说明如下 06-SpringMVC拦截器-用户登录权限控制分析(理解)在day06-Spring练习案例的基础之上：用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登录页面，只有用户登录成功后才能进行后台功能的操作 需求图： 07-SpringMVC拦截器-用户登录权限控制代码实现1(应用)判断用户是否登录 本质：判断session中有没有user，如果没有登陆则先去登陆，如果已经登陆则直接放行访问目标资源 先编写拦截器如下： public class PrivilegeInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException { //逻辑：判断用户是否登录 本质：判断session中有没有user HttpSession session = request.getSession(); User user = (User) session.getAttribute(&quot;user&quot;); if(user==null){ //没有登录 response.sendRedirect(request.getContextPath()+&quot;/login.jsp&quot;); return false; } //放行 访问目标资源 return true; } } 然后配置该拦截器：找到项目案例的spring-mvc.xml，添加如下配置： &lt;!--配置权限拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.PrivilegeInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 08-SpringMVC拦截器-用户登录权限控制代码实现2(应用)在登陆页面输入用户名密码，点击登陆，通过用户名密码进行查询，如果登陆成功，则将用户信息实体存入session，然后跳转到首页，如果登陆失败则继续回到登陆页面 在UserController中编写登陆逻辑 @RequestMapping(&quot;/login&quot;) public String login(String username,String password,HttpSession session){ User user = userService.login(username,password); if(user!=null){ //登录成功 将user存储到session session.setAttribute(&quot;user&quot;,user); return &quot;redirect:/index.jsp&quot;; } return &quot;redirect:/login.jsp&quot;; } service层代码如下： //service层 public User login(String username, String password) { User user = userDao.findByUsernameAndPassword(username,password); return user; } dao层代码如下： //dao层 public User findByUsernameAndPassword(String username, String password) throws EmptyResultDataAccessException{ User user = jdbcTemplate.queryForObject(&quot;select * from sys_user where username=? and password=?&quot;, new BeanPropertyRowMapper&lt;User&gt;(User.class), username, password); return user; } 此时仍然登陆不上，因为我们需要将登陆请求url让拦截器放行,添加资源排除的配置 &lt;!--配置权限拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--配置哪些资源排除拦截操作--&gt; &lt;mvc:exclude-mapping path=&quot;/user/login&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.PrivilegeInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 09-SpringMVC拦截器-用户登录权限控制代码实现3(应用)JdbcTemplate.queryForObject对象如果查询不到数据会抛异常，导致程序无法达到预期效果，如何来解决该问题？ 在业务层处理来自dao层的异常，如果出现异常service层返回null,而不是将异常抛给controller 因此改造登陆的业务层代码,添加异常的控制 public User login(String username, String password) { try { User user = userDao.findByUsernameAndPassword(username,password); return user; }catch (EmptyResultDataAccessException e){ return null; } } 1. SpringMVC异常处理机制1.1 异常处理的思路系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。 系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图： 1.2 异常处理两种方式① 使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver ② 实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器 1.3 简单异常处理器SimpleMappingExceptionResolverSpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置 &lt;!--配置简单映射异常处理器--&gt; &lt;bean class=“org.springframework.web.servlet.handler.SimpleMappingExceptionResolver”&gt; &lt;property name=“defaultErrorView” value=“error”/&gt; 默认错误视图 &lt;property name=“exceptionMappings”&gt; &lt;map&gt; 异常类型 错误视图 &lt;entry key=&quot;com.itheima.exception.MyException&quot; value=&quot;error&quot;/&gt; &lt;entry key=&quot;java.lang.ClassCastException&quot; value=&quot;error&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 1.4 自定义异常处理步骤①创建异常处理器类实现HandlerExceptionResolver public class MyExceptionResolver implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { //处理异常的代码实现 //创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&quot;exceptionPage&quot;); return modelAndView; } } ②配置异常处理器 &lt;bean id=&quot;exceptionResolver&quot; class=&quot;com.itheima.exception.MyExceptionResolver&quot;/&gt; ③编写异常页面 &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 这是一个最终异常的显示页面 &lt;/body&gt; &lt;/html&gt; ④测试异常跳转 @RequestMapping(&quot;/quick22&quot;) @ResponseBody public void quickMethod22() throws IOException, ParseException { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); simpleDateFormat.parse(&quot;abcde&quot;); } 1.5 知识要点异常处理方式 配置简单异常处理器SimpleMappingExceptionResolver 自定义异常处理器 自定义异常处理步骤 ①创建异常处理器类实现HandlerExceptionResolver ②配置异常处理器 ③编写异常页面 ④测试异常跳转 ###","categories":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://lingdas.github.io/tags/springboot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}]},{"title":"Spring与Web环境集成","slug":"Spring与Web环境集成","date":"2021-06-15T00:41:08.000Z","updated":"2021-06-16T06:39:56.000Z","comments":true,"path":"2021/06/15/Spring与Web环境集成/","link":"","permalink":"https://lingdas.github.io/2021/06/15/Spring与Web环境集成/","excerpt":"","text":"1. Spring与Web环境集成1.1 ApplicationContext应用上下文获取方式应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。 在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。 1.2 Spring提供获取应用上下文的工具上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。 所以我们需要做的只有两件事： ①在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标） ②使用WebApplicationContextUtils获得应用上下文对象ApplicationContext 1.3 导入Spring集成web的坐标&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 1.4 配置ContextLoaderListener监听器&lt;!--全局参数--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--Spring的监听器--&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; 1.5 通过工具获得应用上下文对象ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext); Object obj = applicationContext.getBean(&quot;id&quot;); 知识要点 Spring集成web环境步骤 ​ ①配置ContextLoaderListener监听器 ​ ②使用WebApplicationContextUtils获得应用上下文 2. SpringMVC的简介2.1 SpringMVC概述SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。 SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。 2.3 SpringMVC快速入门需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。 开发步骤 ①导入SpringMVC相关坐标 ②配置SpringMVC核心控制器DispathcerServlet ③创建Controller类和视图页面 ④使用注解配置Controller类中业务方法的映射地址 ⑤配置SpringMVC核心文件 spring-mvc.xml ⑥客户端发起请求测试 代码实现 ①导入Spring和SpringMVC的坐标、导入Servlet和Jsp的坐标 &lt;!--Spring坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringMVC坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--Jsp坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; ②在web.xml配置SpringMVC的核心控制器 &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; ③创建Controller和业务方法 public class QuickController { public String quickMethod(){ System.out.println(&quot;quickMethod running.....&quot;); return &quot;index&quot;; } } ③创建视图页面index.jsp &lt;html&gt; &lt;body&gt; &lt;h2&gt;Hello SpringMVC!&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; ④配置注解 @Controller public class QuickController { @RequestMapping(&quot;/quick&quot;) public String quickMethod(){ System.out.println(&quot;quickMethod running.....&quot;); return &quot;index&quot;; } } ⑤创建spring-mvc.xml &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--配置注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt; &lt;/beans&gt; ⑥访问测试地址 http://localhost:8080/itheima_springmvc1/quick 控制台打印 页面显示 2.3 SpringMVC流程图示 2.4 知识要点SpringMVC的开发步骤 ①导入SpringMVC相关坐标 ②配置SpringMVC核心控制器DispathcerServlet ③创建Controller类和视图页面 ④使用注解配置Controller类中业务方法的映射地址 ⑤配置SpringMVC核心文件 spring-mvc.xml ⑥客户端发起请求测试 3. SpringMVC的组件解析3.1 SpringMVC的执行流程 ①用户发送请求至前端控制器DispatcherServlet。 ②DispatcherServlet收到请求调用HandlerMapping处理器映射器。 ③处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 ④DispatcherServlet调用HandlerAdapter处理器适配器。 ⑤HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 ⑥Controller执行完成返回ModelAndView。 ⑦HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 ⑧DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 ⑨ViewReslover解析后返回具体View。 ⑩DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。 3.2 SpringMVC组件解析 前端控制器：DispatcherServlet ​ 用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 处理器映射器：HandlerMapping ​ HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。 处理器适配器：HandlerAdapter ​ 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。 处理器：Handler ​ 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。 视图解析器：View Resolver ​ View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 视图：View ​ SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面 3.3 SpringMVC注解解析@RequestMapping 作用：用于建立请求 URL 和处理请求方法之间的对应关系 位置： ​ 类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录 ​ 方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径 属性： ​ value：用于指定请求的URL。它和path属性的作用是一样的 ​ method：用于指定请求的方式 ​ params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样 例如： ​ params = {“accountName”}，表示请求参数必须有accountName ​ params = {“moeny!100”}，表示请求参数中money不能是100 1.mvc命名空间引入 命名空间：xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; 约束地址：http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd 2.组件扫描 SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;context:component-scan base-package=“com.itheima.controller”/&gt;进行组件扫描。 3.4 SpringMVC的XML配置解析SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下： org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver 翻看该解析器源码，可以看到该解析器的默认设置，如下： REDIRECT_URL_PREFIX = &quot;redirect:&quot; --重定向前缀 FORWARD_URL_PREFIX = &quot;forward:&quot; --转发前缀（默认值） prefix = &quot;&quot;; --视图名称前缀 suffix = &quot;&quot;; --视图名称后缀 视图解析器 我们可以通过属性注入的方式修改视图的的前后缀 &lt;!--配置内部资源视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 3.5 知识要点SpringMVC的相关组件 前端控制器：DispatcherServlet 处理器映射器：HandlerMapping 处理器适配器：HandlerAdapter 处理器：Handler 视图解析器：View Resolver 视图：View SpringMVC的注解和配置 请求映射注解：@RequestMapping 视图解析器配置： REDIRECT_URL_PREFIX = “redirect:” FORWARD_URL_PREFIX = “forward:” prefix = “”; suffix = “”;","categories":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://lingdas.github.io/tags/springboot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}]},{"title":"springmvc02","slug":"springmvc02","date":"2021-06-15T00:41:08.000Z","updated":"2021-06-16T06:40:02.000Z","comments":true,"path":"2021/06/15/springmvc02/","link":"","permalink":"https://lingdas.github.io/2021/06/15/springmvc02/","excerpt":"","text":"SpringMVC的请求和响应SpringMVC的数据响应01-SpringMVC的数据响应-数据响应方式(理解)1) 页面跳转 直接返回字符串 通过ModelAndView对象返回 2） 回写数据 直接返回字符串 返回对象或集合 02-SpringMVC的数据响应-页面跳转-返回字符串形式（应用） 03-SpringMVC的数据响应-页面跳转-返回ModelAndView形式1(应用)在Controller中方法返回ModelAndView对象，并且设置视图名称 @RequestMapping(value=&quot;/quick2&quot;) public ModelAndView save2(){ /* Model:模型 作用封装数据 View：视图 作用展示数据 */ ModelAndView modelAndView = new ModelAndView(); //设置模型数据 modelAndView.addObject(&quot;username&quot;,&quot;itcast&quot;); //设置视图名称 modelAndView.setViewName(&quot;success&quot;); return modelAndView; } 04-SpringMVC的数据响应-页面跳转-返回ModelAndView形式2(应用)n在Controller中方法形参上直接声明ModelAndView，无需在方法中自己创建，在方法中直接使用该对象设置视图，同样可以跳转页面 @RequestMapping(value=&quot;/quick3&quot;) public ModelAndView save3(ModelAndView modelAndView){ modelAndView.addObject(&quot;username&quot;,&quot;itheima&quot;); modelAndView.setViewName(&quot;success&quot;); return modelAndView; } @RequestMapping(value=&quot;/quick4&quot;) public String save4(Model model){ model.addAttribute(&quot;username&quot;,&quot;博学谷&quot;); return &quot;success&quot;; } 05-SpringMVC的数据响应-页面跳转-返回ModelAndView3(应用)在Controller方法的形参上可以直接使用原生的HttpServeltRequest对象，只需声明即可 @RequestMapping(value=&quot;/quick5&quot;) public String save5(HttpServletRequest request){ request.setAttribute(&quot;username&quot;,&quot;酷丁鱼&quot;); return &quot;success&quot;; } 06-SpringMVC的数据响应-回写数据-直接回写字符串(应用)通过SpringMVC框架注入的response对象，使用response.getWriter().print(“hello world”) 回写数据，此时不需要视图跳转，业务方法返回值为void 将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回 @RequestMapping(value=&quot;/quick7&quot;) @ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应 public String save7() throws IOException { return &quot;hello itheima&quot;; } @RequestMapping(value=&quot;/quick6&quot;) public void save6(HttpServletResponse response) throws IOException { response.getWriter().print(&quot;hello itcast&quot;); } 07-SpringMVC的数据响应-回写数据-直接回写json格式字符串(应用)@RequestMapping(value=&quot;/quick8&quot;) @ResponseBody public String save8() throws IOException { return &quot;{\\&quot;username\\&quot;:\\&quot;zhangsan\\&quot;,\\&quot;age\\&quot;:18}&quot;; } 手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换,通过jackson转换json格式字符串，回写字符串 @RequestMapping(value=&quot;/quick9&quot;) @ResponseBody public String save9() throws IOException { User user = new User(); user.setUsername(&quot;lisi&quot;); user.setAge(30); //使用json的转换工具将对象转换成json格式字符串在返回 ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(user); return json; } 08-SpringMVC的数据响应-回写数据-返回对象或集合(应用)通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置： &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; @RequestMapping(value=&quot;/quick10&quot;) @ResponseBody //期望SpringMVC自动将User转换成json格式的字符串 public User save10() throws IOException { User user = new User(); user.setUsername(&quot;lisi2&quot;); user.setAge(32); return user; } 09-SpringMVC的数据响应-回写数据-返回对象或集合2(应用)在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置 &lt;mvc:annotation-driven/&gt; 在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。 使用&lt;mvc:annotation-driven /&gt;自动加载 RequestMappingHandlerMapping（处理映射器）和 RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在Spring-xml.xml配置文件中使用 &lt;mvc:annotation-driven /&gt;替代注解处理器和适配器的配置。 同时使用&lt;mvc:annotation-driven /&gt; 默认底层就会集成jackson进行对象或集合的json格式字符串的转换 10-SpringMVC的数据响应-知识要点小结(理解，记忆)1） 页面跳转 直接返回字符串 通过ModelAndView对象返回 2） 回写数据 直接返回字符串 HttpServletResponse 对象直接写回数据，HttpServletRequest对象带回数据，Model对象带回数据或者@ResponseBody将字符串数据写回 返回对象或集合 @ResponseBody+&lt;mvc:annotation-driven/&gt; SpringMVC的请求11-SpringMVC的请求-获得请求参数-请求参数类型(理解)客户端请求参数的格式是：name=value&amp;name=value…… 服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数 基本类型参数 POJO类型参数 数组类型参数 集合类型参数 12-SpringMVC的请求-获得请求参数-获得基本类型参数(应用)Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换； 自动的类型转换是指从String向其他类型的转换 http://localhost:8080/itheima_springmvc1/quick9?username=zhangsan&amp;age=12 @RequestMapping(value=&quot;/quick11&quot;) @ResponseBody public void save11(String username,int age) throws IOException { System.out.println(username); System.out.println(age); } 13-SpringMVC的请求-获得请求参数-获得POJO类型参数(应用)Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。 package com.itheima.domain; public class User { private String username; private int age; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;User{&quot; + &quot;username=&#39;&quot; + username + &#39;\\&#39;&#39; + &quot;, age=&quot; + age + &#39;}&#39;; } } @RequestMapping(value=&quot;/quick12&quot;) @ResponseBody public void save12(User user) throws IOException { System.out.println(user); } 14-SpringMVC的请求-获得请求参数-获得数组类型参数(应用)Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。 @RequestMapping(value=&quot;/quick13&quot;) @ResponseBody public void save13(String[] strs) throws IOException { System.out.println(Arrays.asList(strs)); } 15-SpringMVC的请求-获得请求参数-获得集合类型参数1(应用)获得集合参数时，要将集合参数包装到一个POJO中才可以。 &lt;form action=&quot;${pageContext.request.contextPath}/user/quick14&quot; method=&quot;post&quot;&gt; &lt;%--表明是第一个User对象的username age--%&gt; &lt;input type=&quot;text&quot; name=&quot;userList[0].username&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;userList[0].age&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;userList[1].username&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;userList[1].age&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; package com.itheima.domain; import java.util.List; public class VO { private List&lt;User&gt; userList; public List&lt;User&gt; getUserList() { return userList; } public void setUserList(List&lt;User&gt; userList) { this.userList = userList; } @Override public String toString() { return &quot;VO{&quot; + &quot;userList=&quot; + userList + &#39;}&#39;; } } @RequestMapping(value=&quot;/quick14&quot;) @ResponseBody public void save14(VO vo) throws IOException { System.out.println(vo); } 16-SpringMVC的请求-获得请求参数-获得集合类型参数2(应用)当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装 &lt;script src=&quot;${pageContext.request.contextPath}/js/jquery-3.3.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var userList = new Array(); userList.push({username:&quot;zhangsan&quot;,age:18}); userList.push({username:&quot;lisi&quot;,age:28}); $.ajax({ type:&quot;POST&quot;, url:&quot;${pageContext.request.contextPath}/user/quick15&quot;, data:JSON.stringify(userList), contentType:&quot;application/json;charset=utf-8&quot; }); &lt;/script&gt; @RequestMapping(value=&quot;/quick15&quot;) @ResponseBody public void save15(@RequestBody List&lt;User&gt; userList) throws IOException { System.out.println(userList); } 17-SpringMVC的请求-获得请求参数-静态资源访问的开启(应用)当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源： •在spring-mvc.xml配置文件中指定放行的资源 ​ &lt;mvc:resources mapping=&quot;/js/**&quot;location=&quot;/js/&quot;/&gt; •使用&lt;mvc:default-servlet-handler/&gt;标签 &lt;!--开发资源的访问--&gt; &lt;!--&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt; &lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;/&gt;--&gt; &lt;mvc:default-servlet-handler/&gt; 18-SpringMVC的请求-获得请求参数-配置全局乱码过滤器(应用)当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。 &lt;!--配置全局过滤的filter--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 19-SpringMVC的请求-获得请求参数-参数绑定注解@RequestParam(应用)当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定 &lt;form action=&quot;${pageContext.request.contextPath}/quick16&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt; &lt;/form&gt; @RequestMapping(value=&quot;/quick16&quot;) @ResponseBody public void save16(@RequestParam(value=&quot;name&quot;,required = false,defaultValue = &quot;itcast&quot;) String username) throws IOException { System.out.println(username); } 20-SpringMVC的请求-获得请求参数-Restful风格的参数的获取(应用)Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。 Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下： GET：用于获取资源 POST：用于新建资源 PUT：用于更新资源 DELETE：用于删除资源 例如： /user/1 GET ： 得到 id = 1 的 user /user/1 DELETE： 删除 id = 1 的 user /user/1 PUT： 更新 id = 1 的 user /user POST： 新增 user 上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。 http://localhost:8080/itheima_springmvc1/quick17/zhangsan @RequestMapping(value=&quot;/quick17/{name}&quot;) @ResponseBody public void save17(@PathVariable(value=&quot;name&quot;) String username) throws IOException { System.out.println(username); } 21-SpringMVC的请求-获得请求参数-自定义类型转换器(应用)SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。 但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。 public class DateConverter implements Converter&lt;String, Date&gt; { public Date convert(String dateStr) { //将日期字符串转换成日期对象 返回 SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = null; try { date = format.parse(dateStr); } catch (ParseException e) { e.printStackTrace(); } return date; } } @RequestMapping(value=&quot;/quick18&quot;) @ResponseBody public void save18(Date date) throws IOException { System.out.println(date); } 22-SpringMVC的请求-获得请求参数-获得Servlet相关API(应用)SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下： HttpServletRequest HttpServletResponse HttpSession @RequestMapping(value=&quot;/quick19&quot;) @ResponseBody public void save19(HttpServletRequest request, HttpServletResponse response, HttpSession session) throws IOException { System.out.println(request); System.out.println(response); System.out.println(session); } 23-SpringMVC的请求-获得请求参数-获得请求头信息(应用)使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name) @RequestHeader注解的属性如下： value：请求头的名称 required：是否必须携带此请求头 @RequestMapping(value=&quot;/quick20&quot;) @ResponseBody public void save20(@RequestHeader(value = &quot;User-Agent&quot;,required = false) String user_agent) throws IOException { System.out.println(user_agent); } 使用@CookieValue可以获得指定Cookie的值 @CookieValue注解的属性如下： value：指定cookie的名称 required：是否必须携带此cookie @RequestMapping(value=&quot;/quick21&quot;) @ResponseBody public void save21(@CookieValue(value = &quot;JSESSIONID&quot;) String jsessionId) throws IOException { System.out.println(jsessionId); }","categories":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://lingdas.github.io/tags/springboot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}]},{"title":"酷我音乐爬取","slug":"酷我音乐爬取","date":"2021-06-15T00:41:08.000Z","updated":"2021-06-16T12:38:30.793Z","comments":true,"path":"2021/06/15/酷我音乐爬取/","link":"","permalink":"https://lingdas.github.io/2021/06/15/酷我音乐爬取/","excerpt":"","text":"酷我音乐爬虫主要接口获取歌曲下载地址 http://www.kuwo.cn/url?format=mp3&amp;rid=173345979&amp;response=url&amp;type=convert_url3&amp;br=320kmp3&amp;from=web&amp;t=1623843977328&amp;httpsStatus=1 获取结果url 是歌曲的下载地址 {&quot;code&quot;: 200, &quot;msg&quot;: &quot;success&quot;, &quot;url&quot;: &quot;https://gv-sycdn.kuwo.cn/8ee6ee8edbbafa235e08991ac4382519/60c9e6b6/resource/n2/30/9/3326431231.mp3&quot;} 主要参数rid 歌曲的idbr 歌曲的码率 320是最高码率t 时间戳用python 拼凑参数 base_url = &#39;http://www.kuwo.cn/url&#39; params = { &#39;format&#39;: &#39;mp3&#39;, &#39;rid&#39;: rid, &#39;response&#39;: &#39;url&#39;, &#39;type&#39;: &#39;convert_url3&#39;, &#39;br&#39;: &#39;320kmp3&#39;, # 320K 代表是无陨音质。 &#39;from&#39;: &#39;web&#39;, &#39;t&#39;: str(int(time.time() * 1000)), &#39;httpsStatus&#39;: &#39;1&#39; } 获取歌曲rid http://www.kuwo.cn/api/www/search/searchMusicBykeyWord?key=%E9%99%88%E6%85%A7%E7%90%B3&amp;pn=1&amp;rn=30&amp;httpsStatus=1 主要参数key 你要得歌曲或者作者得名字pn 当前得页数rn 一页显示多少首 请求时header需要的参数CookieUser-Agent 浏览器表示csrf Cookie中的kw_token的值Host 主域名Referer 来源 获取结果rid 歌曲的ID name 歌曲名字 songTimeMinutes 歌曲的时长 { &quot;code&quot;: 200, &quot;curTime&quot;: 1623845910234, &quot;data&quot;: { &quot;total&quot;: &quot;1577&quot;, &quot;list&quot;: [ { &quot;musicrid&quot;: &quot;MUSIC_7165139&quot;, &quot;barrage&quot;: &quot;0&quot;, &quot;artist&quot;: &quot;卢冠廷&amp;张智霖&amp;成龙&amp;许冠杰&amp;陈慧琳&amp;陈慧娴&amp;李克勤&amp;G.E.M.邓紫棋&amp;张学友&amp;陈奕迅&amp;谭咏麟&quot;, &quot;mvpayinfo&quot;: { &quot;play&quot;: &quot;0&quot;, &quot;vid&quot;: &quot;3991780&quot;, &quot;download&quot;: &quot;0&quot; }, &quot;pic&quot;: &quot;https://img4.kuwo.cn/star/albumcover/120/26/5/2778776974.jpg&quot;, &quot;isstar&quot;: 0, &quot;rid&quot;: 7165139, &quot;duration&quot;: 255, &quot;score100&quot;: &quot;79&quot;, &quot;content_type&quot;: &quot;0&quot;, &quot;track&quot;: 0, &quot;hasLossless&quot;: false, &quot;hasmv&quot;: 1, &quot;album&quot;: &quot;真的英雄&quot;, &quot;albumid&quot;: &quot;558959&quot;, &quot;pay&quot;: &quot;0&quot;, &quot;artistid&quot;: 690, &quot;albumpic&quot;: &quot;https://img4.kuwo.cn/star/albumcover/120/26/5/2778776974.jpg&quot;, &quot;originalsongtype&quot;: 1, &quot;songTimeMinutes&quot;: &quot;04:15&quot;, &quot;isListenFee&quot;: false, &quot;pic120&quot;: &quot;https://img4.kuwo.cn/star/albumcover/120/26/5/2778776974.jpg&quot;, &quot;name&quot;: &quot;真的英雄&quot;, &quot;online&quot;: 1, &quot;payInfo&quot;: { &quot;play&quot;: &quot;0000&quot;, &quot;download&quot;: &quot;0000&quot;, &quot;local_encrypt&quot;: &quot;0&quot;, &quot;limitfree&quot;: &quot;0&quot;, &quot;cannotDownload&quot;: &quot;0&quot;, &quot;cannotOnlinePlay&quot;: &quot;0&quot;, &quot;feeType&quot;: { &quot;song&quot;: &quot;0&quot;, &quot;album&quot;: &quot;0&quot;, &quot;vip&quot;: &quot;0&quot;, &quot;bookvip&quot;: &quot;0&quot; }, &quot;listen_fragment&quot;: &quot;0&quot;, &quot;tips_intercept&quot;: &quot;0&quot; } }, { &quot;musicrid&quot;: &quot;MUSIC_86371&quot;, &quot;barrage&quot;: &quot;0&quot;, &quot;artist&quot;: &quot;陈慧琳&quot;, &quot;mvpayinfo&quot;: { &quot;play&quot;: &quot;0&quot;, &quot;vid&quot;: &quot;253402&quot;, &quot;download&quot;: &quot;0&quot; }, &quot;pic&quot;: &quot;https://img4.kuwo.cn/star/albumcover/120/70/38/3191802684.jpg&quot;, &quot;isstar&quot;: 0, &quot;rid&quot;: 86371, &quot;duration&quot;: 247, &quot;score100&quot;: &quot;79&quot;, &quot;content_type&quot;: &quot;0&quot;, &quot;track&quot;: 0, &quot;hasLossless&quot;: false, &quot;hasmv&quot;: 1, &quot;album&quot;: &quot;闪亮每一天Shining&amp;nbsp;新歌&amp;nbsp;+&amp;nbsp;精选&quot;, &quot;albumid&quot;: &quot;24050&quot;, &quot;pay&quot;: &quot;16515324&quot;, &quot;artistid&quot;: 871, &quot;albumpic&quot;: &quot;https://img4.kuwo.cn/star/albumcover/120/70/38/3191802684.jpg&quot;, &quot;originalsongtype&quot;: 0, &quot;songTimeMinutes&quot;: &quot;04:07&quot;, &quot;isListenFee&quot;: false, &quot;pic120&quot;: &quot;https://img4.kuwo.cn/star/albumcover/120/70/38/3191802684.jpg&quot;, &quot;name&quot;: &quot;记事本-选自“我的秘密花园2”&quot;, &quot;online&quot;: 1, &quot;payInfo&quot;: { &quot;play&quot;: &quot;1100&quot;, &quot;download&quot;: &quot;1111&quot;, &quot;local_encrypt&quot;: &quot;1&quot;, &quot;limitfree&quot;: &quot;0&quot;, &quot;cannotDownload&quot;: &quot;0&quot;, &quot;cannotOnlinePlay&quot;: &quot;0&quot;, &quot;feeType&quot;: { &quot;song&quot;: &quot;1&quot;, &quot;album&quot;: &quot;0&quot;, &quot;vip&quot;: &quot;1&quot;, &quot;bookvip&quot;: &quot;0&quot; }, &quot;listen_fragment&quot;: &quot;0&quot;, &quot;tips_intercept&quot;: &quot;0&quot; } }, python实战import time, os, requests, threading, re, multiprocessing from multiprocessing import Pool class KuwoMusic: def __init__(self,cookie): self.cookie = cookie def get_music_url(self, rid): # http://www.kuwo.cn/url?format=mp3&amp;rid=440613&amp;response=url&amp;type=convert_url3&amp;br=320kmp3&amp;from=web&amp;t=1620179066636&amp;httpsStatus=1 base_url = &#39;http://www.kuwo.cn/url&#39; params = { &#39;format&#39;: &#39;mp3&#39;, &#39;rid&#39;: rid, &#39;response&#39;: &#39;url&#39;, &#39;type&#39;: &#39;convert_url3&#39;, &#39;br&#39;: &#39;320kmp3&#39;, # 320K 代表是无陨音质。 &#39;from&#39;: &#39;web&#39;, &#39;t&#39;: str(int(time.time() * 1000)), &#39;httpsStatus&#39;: &#39;1&#39; } headers = { &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Host&#39;: &#39;www.kuwo.cn&#39;, &#39;Referer&#39;: &#39;http://www.kuwo.cn/search/list&#39;, &#39;Cookie&#39;: self.cookie, &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&#39; } resp = requests.get(url=base_url, params=params, headers=headers) music_url = resp.json().get(&quot;url&quot;) return music_url def music_download(self, url, name): host = re.findall(&#39;https://(.*?)/&#39;, url)[0] headers = { &#39;Accept&#39;: &#39;*/*&#39;, &#39;sec-ch-ua&#39;: &#39;&quot; Not A;Brand&quot;;v = &quot;99&quot;, &quot;Chromium&quot;;v = &quot;90&quot;, &quot;Google Chrome&quot;;v = &quot;90&quot;&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Host&#39;: host, &#39;Referer&#39;: url, &#39;Cookie&#39;: self.cookie, &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&#39; } print(name + &quot;.mp3\\t开始下载...&quot;) data = requests.get(url=url, headers=headers).content try: if not os.path.exists(&quot;音乐下载&quot;): os.mkdir(&quot;音乐下载&quot;) except: pass filepath = &quot;音乐下载/&quot; + name + &#39;.mp3&#39; with open(filepath, &#39;wb&#39;) as f: f.write(data) print(name + &quot;.mp3\\t下载完成.&quot;) def get_music_list(self, key, pn): # http://www.kuwo.cn/api/www/search/searchMusicBykeyWord?key=%E5%91%A8%E6%9D%B0%E4%BC%A6&amp;pn=1&amp;rn=30&amp;httpsStatus=1&amp;reqId=1aee48d0-ad43-11eb-b9fa-5f2f406dcb43 base_url = &#39;http://www.kuwo.cn/api/www/search/searchMusicBykeyWord&#39; params = { &#39;key&#39;: key, &#39;pn&#39;: pn, &#39;rn&#39;: 30, &#39;httpsStatus&#39;: &#39;1&#39; } csrf = re.findall(&quot;kw_token=(.{11})&quot;, self.cookie)[0] headers = { &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Cookie&#39;: self.cookie, &#39;csrf&#39;: csrf, # 这个值是cookie 里面的 kw_token值 &#39;Host&#39;: &#39;www.kuwo.cn&#39;, &#39;Referer&#39;: &#39;http://www.kuwo.cn/search/list&#39;, &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36&#39; } resp = requests.get(url=base_url, params=params, headers=headers) music_data = [] if len(resp.text) &gt; 88: # 出错返回长度是84 music_list = resp.json() music_list = music_list[&#39;data&#39;][&#39;list&#39;] for music in music_list: artist = music[&#39;artist&#39;] # 歌曲演唱者 artist = self.rename_use(artist) name = music[&#39;name&#39;] name = self.rename_use(name) rid = music[&#39;rid&#39;] # 歌曲 rid duration = music[&#39;duration&#39;] # 这个值是歌曲时长，单位是 秒 duration = self.s_to_m(duration) music_data.append({&#39;name&#39;: name, &#39;artist&#39;: artist, &#39;rid&#39;: rid, &#39;duration&#39;: duration}) else: print(&quot;数据获取失败，请重试。&quot;) return music_data def reset_list(self, a): # 列表去重复数据， a 代表一下列表 c = [] for i in range(len(a)): b = a.pop() if b not in a: c.append(b) return c def rename_use(self, file_name): file_name = file_name.replace(&quot;\\\\&quot;, &#39;&#39;).replace(&quot;/&quot;, &#39;&#39;).replace(&quot;:&quot;, &#39;&#39;).replace(&quot;*&quot;, &#39;&#39;).replace(&quot;?&quot;, &#39;&#39;).replace( &#39;&quot;&#39;, &#39;&#39;).replace(&quot;&lt;&quot;, &#39;&#39;).replace(&quot;&gt;&quot;, &#39;&#39;).replace(&quot;|&quot;, &#39;&#39;).replace(&quot;&amp;nbsp;&quot;, &quot;&quot;) return file_name def s_to_m(self, s): m = int(s) / 60 a = m - int(m) b = a * 60 b = int(b) if int(b) &lt; 10: b = &quot;0&quot; + str(int(b)) ms = str(int(m)) + &quot;：&quot; + str(b) return ms def show_short(self, name): if len(name) &gt; 18: name = name[:18] + &quot;..&quot; return name def main(self): inp = input(&quot;请输入歌曲名或歌手：\\n&quot;) pn = 1 musics_all = [] while True: music_data = self.get_music_list(inp, pn=pn) if music_data: musics_all.append(music_data) # 在这里判断去重，也行。只是把去重方法写出来才想到， 唉！！ for i, music in enumerate(music_data): artist = music[&#39;artist&#39;] # 歌曲演唱者 artist = self.show_short(artist) name = music[&#39;name&#39;] name = self.show_short(name) rid = music[&#39;rid&#39;] # 歌曲 rid duration = music[&#39;duration&#39;] # 歌曲时长 单位 秒 songTimeMinutes print(f&quot;{i + 1}. {name} \\t演唱:{artist} \\t时长:{duration}&quot;) print(&quot;*&quot; * 40 + &quot; 华丽的分割线 &quot; + &quot;*&quot; * 40) if pn == 1: print(&quot;请选择下载方式： \\n1.按歌曲编号下载 \\t3.下一页\\t4.全部下载\\t 按0退出\\n&quot;) elif pn &gt; 1: print(&quot;请选择下载方式： \\n1.按歌曲编号下载 \\t2.上一页 \\t3.下一页\\t4.全部下载\\t 按0退出\\n&quot;) inp_b = input() if inp_b == &#39;1&#39;: while True: print(&quot;选择歌曲编号，加入下载..输入&#39;0&#39;, 退出&quot;) inp_c = input(&quot;&quot;) if int(inp_c) in [i for i in range(1, 31)]: rid = music_data[int(inp_c) - 1][&#39;rid&#39;] artist = music_data[int(inp_c) - 1][&#39;artist&#39;] name = music_data[int(inp_c) - 1][&#39;name&#39;] music_url = self.get_music_url(rid) music_name = name + &quot;-&quot; + artist th = threading.Thread(target=self.music_download, args=(music_url, music_name)) th.start() # th.join() print(&quot;添加成功，请继续&quot;) elif inp_c == &#39;0&#39;: print(&quot;成功退出&quot;) break else: print(&quot;输入有误,是对应歌曲的编号（1,4 或是 12）&quot;) time.sleep(3) elif inp_b == &#39;2&#39;: pn -= 1 if pn &lt;1: print(&quot;操作不当，请重试&quot;) pn = 1 elif inp_b == &#39;3&#39;: pn += 1 elif inp_b == &#39;4&#39;: musics_all = self.reset_list(musics_all) # 去除重复歌单 for musics in musics_all: for music in musics: rid = music[&#39;rid&#39;] artist = music[&#39;artist&#39;] name = music[&#39;name&#39;] music_url = self.get_music_url(rid) music_name = name + &quot;-&quot; + artist # print(music_name,music_url) # th = threading.Thread(target=self.music_download, args=(music_url, music_name)) # th.start() # th.join() pool.apply_async(self.music_download, args=(music_url, music_name)) pool.close() pool.join() print(&quot;下载完毕，程序即将退出&quot;) time.sleep(2) break elif inp_b == &#39;0&#39;: print(&#39;成功退出，程序即将关闭&#39;) time.sleep(2) break else: print(&quot;可能输入有误，可以重试&quot;) time.sleep(2) else: print(&quot;数据获取失败，或没有更多歌曲了&quot;) time.sleep(2) def get_cookie(): url = &#39;http://www.kuwo.cn/&#39; headers = { &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Host&#39;: &#39;www.kuwo.cn&#39;, &#39;Referer&#39;: &#39;http://www.kuwo.cn/&#39;, &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&#39; } res = requests.get(url=url, headers=headers) cookies = res.cookies.items() cookie = &#39;&#39; for name, value in cookies: cookie += &#39;{0}={1};&#39;.format(name, value) return cookie if __name__ == &#39;__main__&#39;: multiprocessing.freeze_support() pool = Pool(3) cookie = get_cookie() kuwo = KuwoMusic(cookie) kuwo.main()","categories":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lingdas.github.io/tags/python/"},{"name":"酷我音乐爬取\"","slug":"酷我音乐爬取","permalink":"https://lingdas.github.io/tags/酷我音乐爬取/"},{"name":"爬虫","slug":"爬虫","permalink":"https://lingdas.github.io/tags/爬虫/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}]},{"title":"JdbcTemplate","slug":"JdbcTemplate","date":"2021-06-14T03:33:38.000Z","updated":"2021-06-16T06:40:14.000Z","comments":true,"path":"2021/06/14/JdbcTemplate/","link":"","permalink":"https://lingdas.github.io/2021/06/14/JdbcTemplate/","excerpt":"","text":"JdbcTemplate基本使用01-JdbcTemplate基本使用-概述(了解)JdbcTemplate是spring框架中提供的一个对象，是对原始繁琐的Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类。例如：操作关系型数据的JdbcTemplate和HibernateTemplate，操作nosql数据库的RedisTemplate，操作消息队列的JmsTemplate等等。 02-JdbcTemplate基本使用-开发步骤(理解)①导入spring-jdbc和spring-tx坐标 ②创建数据库表和实体 ③创建JdbcTemplate对象 ④执行数据库操作 03-JdbcTemplate基本使用-快速入门代码实现(应用)导入spring-jdbc和spring-tx坐标 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;itheima_spring_jdbc&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;itheima_spring_jdbc Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&#39;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 创建数据库表和实体 package com.itheima.domain; public class Account { private String name; private double money; public String getNa me() { return name; } public void setName(String name) { this.name = name; } public double getMoney() { return money; } public void setMoney(double money) { this.money = money; } @Override public String toString() { return &quot;Account{&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, money=&quot; + money + &#39;}&#39;; } } 创建JdbcTemplate对象 执行数据库操作 @Test //测试JdbcTemplate开发步骤 public void test1() throws PropertyVetoException { //创建数据源对象 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); JdbcTemplate jdbcTemplate = new JdbcTemplate(); //设置数据源对象 知道数据库在哪 jdbcTemplate.setDataSource(dataSource); //执行操作 int row = jdbcTemplate.update(&quot;insert into account values(?,?)&quot;, &quot;tom&quot;, 5000); System.out.println(row); } 04-JdbcTemplate基本使用-spring产生模板对象分析(理解)我们可以将JdbcTemplate的创建权交给Spring，将数据源DataSource的创建权也交给Spring，在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中,然后通过Spring容器获得JdbcTemplate对象来执行操作。 05-JdbcTemplate基本使用-spring产生模板对象代码实现(应用)配置如下： &lt;!--数据源对象--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///test&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--jdbc模板对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 测试代码 @Test //测试Spring产生jdbcTemplate对象 public void test2() throws PropertyVetoException { ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class); int row = jdbcTemplate.update(&quot;insert into account values(?,?)&quot;, &quot;lisi&quot;, 5000); System.out.println(row); } 06-JdbcTemplate基本使用-spring产生模板对象代码实现（抽取jdbc.properties）(应用)将数据库的连接信息抽取到外部配置文件中，和spring的配置文件分离开，有利于后期维护 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/test jdbc.username=root jdbc.password=root 配置文件修改为: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd &quot;&gt; &lt;!--加载jdbc.properties--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--数据源对象--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/bean&gt; &lt;!--jdbc模板对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 07-JdbcTemplate基本使用-常用操作-更新操作(应用)package com.itheima.test; import com.itheima.domain.Account; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import java.util.List; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class JdbcTemplateCRUDTest { @Autowired private JdbcTemplate jdbcTemplate; //修改更新 @Test public void testUpdate(){ jdbcTemplate.update(&quot;update account set money=? where name=?&quot;,10000,&quot;tom&quot;); } //删除 @Test public void testDelete(){ jdbcTemplate.update(&quot;delete from account where name=?&quot;,&quot;tom&quot;); } } 08-JdbcTemplate基本使用-常用操作-查询操作(应用)package com.itheima.test; import com.itheima.domain.Account; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import java.util.List; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class JdbcTemplateCRUDTest { @Autowired private JdbcTemplate jdbcTemplate; //聚合查询 @Test public void testQueryCount(){ Long count = jdbcTemplate.queryForObject(&quot;select count(*) from account&quot;, Long.class); System.out.println(count); } //查询一个 @Test public void testQueryOne(){ Account account = jdbcTemplate.queryForObject(&quot;select * from account where name=?&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class), &quot;tom&quot;); System.out.println(account); } //查询所有 @Test public void testQueryAll(){ List&lt;Account&gt; accountList = jdbcTemplate.query(&quot;select * from account&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); System.out.println(accountList); } } 09-JdbcTemplate基本使用-知识要点(理解，记忆)①导入spring-jdbc和spring-tx坐标 ②创建数据库表和实体 ③创建JdbcTemplate对象 JdbcTemplate jdbcTemplate = newJdbcTemplate(); jdbcTemplate.setDataSource(dataSource); ④执行数据库操作 更新操作： jdbcTemplate.update (sql,params) 查询操作： jdbcTemplate.query (sql,Mapper,params) jdbcTemplate.queryForObject(sql,Mapper,params) 声明式事务控制1. 编程式事务控制相关对象1.1 PlatformTransactionManagerPlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。 注意： PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如：Dao 层技术是jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager Dao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager 1.2 TransactionDefinitionTransactionDefinition 是事务的定义信息对象，里面有如下方法： 1. 事务隔离级别设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED ISOLATION_READ_COMMITTED ISOLATION_REPEATABLE_READ ISOLATION_SERIALIZABLE 2. 事务传播行为 REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER：以非事务方式运行，如果当前存在事务，抛出异常 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作 超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置 是否只读：建议查询时设置为只读 1.3 TransactionStatusTransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。 1.4 知识要点编程式事务控制三大对象 PlatformTransactionManager TransactionDefinition TransactionStatus 2 基于 XML 的声明式事务控制2.1 什么是声明式事务控制Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。 声明式事务处理的作用 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便 注意：Spring 声明式事务控制底层就是AOP。 2.2 声明式事务控制的实现声明式事务控制明确事项： 谁是切点？ 谁是通知？ 配置切面？ ①引入tx命名空间 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; ②配置事务增强 &lt;!--平台事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--事务增强配置--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; ③配置事务 AOP 织入 &lt;!--事务的aop增强--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; ④测试事务控制转账业务代码 @Override public void transfer(String outMan, String inMan, double money) { accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money); } 2.3 切点方法的事务参数的配置&lt;!--事务增强配置--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 其中，tx:method 代表切点方法的事务参数的配置，例如： &lt;tx:method name=&quot;transfer&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; timeout=&quot;-1&quot; read-only=&quot;false&quot;/&gt; name：切点方法名称 isolation:事务的隔离级别 propogation：事务的传播行为 timeout：超时时间 read-only：是否只读 2.4 知识要点声明式事务控制的配置要点 平台事务管理器配置 事务通知的配置 事务aop织入的配置 3 基于注解的声明式事务控制3.1 使用注解配置声明式事务控制 编写 AccoutDao @Repository(&quot;accountDao&quot;) public class AccountDaoImpl implements AccountDao { @Autowired private JdbcTemplate jdbcTemplate; public void out(String outMan, double money) { jdbcTemplate.update(&quot;update account set money=money-? where name=?&quot;,money,outMan); } public void in(String inMan, double money) { jdbcTemplate.update(&quot;update account set money=money+? where name=?&quot;,money,inMan); } } 编写 AccoutService @Service(&quot;accountService&quot;) @Transactional public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED) public void transfer(String outMan, String inMan, double money) { accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money); } } 编写 applicationContext.xml 配置文件 &lt;!—之前省略datsSource、jdbcTemplate、平台事务管理器的配置--&gt; &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt; &lt;!--事务的注解驱动--&gt; &lt;tx:annotation-driven/&gt; 3.2 注解配置声明式事务控制解析①使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。 ②注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。 ③使用在方法上，不同的方法可以采用不同的事务参数配置。 ④Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven /&gt; 3.3 知识要点注解声明式事务控制的配置要点 平台事务管理器配置（xml方式） 事务通知的配置（@Transactional注解配置） 事务注解驱动的配置 tx:annotation-driven/","categories":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://lingdas.github.io/tags/springboot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}]},{"title":"SpringIoC和DI注解开发","slug":"02-SpringIoC和DI注解开发","date":"2021-06-14T01:42:14.000Z","updated":"2021-06-16T06:40:24.000Z","comments":true,"path":"2021/06/14/02-SpringIoC和DI注解开发/","link":"","permalink":"https://lingdas.github.io/2021/06/14/02-SpringIoC和DI注解开发/","excerpt":"","text":"1.Spring配置数据源1.1 数据源（连接池）的作用数据源(连接池)是提高程序性能如出现的 事先实例化数据源，初始化部分连接资源 使用连接资源时从数据源中获取 使用完毕后将连接资源归还给数据源 常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等 开发步骤 ①导入数据源的坐标和数据库驱动坐标 ②创建数据源对象 ③设置数据源的基本连接数据 ④使用数据源获取连接资源和归还连接资源 1.2 数据源的手动创建①导入c3p0和druid的坐标 &lt;!-- C3P0连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Druid连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; ①导入mysql数据库驱动坐标 &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt; &lt;/dependency&gt; ②创建C3P0连接池 @Test public void testC3P0() throws Exception { //创建数据源 ComboPooledDataSource dataSource = new ComboPooledDataSource(); //设置数据库连接参数 dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection); } ②创建Druid连接池 @Test public void testDruid() throws Exception { //创建数据源 DruidDataSource dataSource = new DruidDataSource(); //设置数据库连接参数 dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection); } ③提取jdbc.properties配置文件 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/test jdbc.username=root jdbc.password=root ④读取jdbc.properties配置文件创建连接池 @Test public void testC3P0ByProperties() throws Exception { //加载类路径下的jdbc.properties ResourceBundle rb = ResourceBundle.getBundle(&quot;jdbc&quot;); ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(rb.getString(&quot;jdbc.driver&quot;)); dataSource.setJdbcUrl(rb.getString(&quot;jdbc.url&quot;)); dataSource.setUser(rb.getString(&quot;jdbc.username&quot;)); dataSource.setPassword(rb.getString(&quot;jdbc.password&quot;)); Connection connection = dataSource.getConnection(); System.out.println(connection); } 1.3 Spring配置数据源可以将DataSource的创建权交由Spring容器去完成 DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的 DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入 &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; 测试从容器当中获取数据源 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DataSource dataSource = (DataSource) applicationContext.getBean(&quot;dataSource&quot;); Connection connection = dataSource.getConnection(); System.out.println(connection); 1.4 抽取jdbc配置文件applicationContext.xml加载jdbc.properties配置文件获得连接信息。 首先，需要引入context命名空间和约束路径： 命名空间：xmlns:context=”http://www.springframework.org/schema/context&quot; 约束路径：http://www.springframework.org/schema/context​ ​ http://www.springframework.org/schema/context/spring-context.xsd &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/bean&gt; 1.5 知识要点Spring容器加载properties文件 &lt;context:property-placeholder location=&quot;xx.properties&quot;/&gt; &lt;property name=&quot;&quot; value=&quot;${key}&quot;/&gt; 2. Spring注解开发2.1 Spring原始注解Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。 Spring原始注解主要是替代的配置 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 注意： 使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。 &lt;!--注解的组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt; 使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。 //@Component(&quot;userDao&quot;) @Repository(&quot;userDao&quot;) public class UserDaoImpl implements UserDao { @Override public void save() { System.out.println(&quot;save running... ...&quot;); } } 使用@Compont或@Service标识UserServiceImpl需要Spring进行实例化 使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入 //@Component(&quot;userService&quot;) @Service(&quot;userService&quot;) public class UserServiceImpl implements UserService { /*@Autowired @Qualifier(&quot;userDao&quot;)*/ @Resource(name=&quot;userDao&quot;) private UserDao userDao; @Override public void save() { userDao.save(); } } 使用@Value进行字符串的注入 @Repository(&quot;userDao&quot;) public class UserDaoImpl implements UserDao { @Value(&quot;注入普通数据&quot;) private String str; @Value(&quot;${jdbc.driver}&quot;) private String driver; @Override public void save() { System.out.println(str); System.out.println(driver); System.out.println(&quot;save running... ...&quot;); } } 使用@Scope标注Bean的范围 //@Scope(&quot;prototype&quot;) @Scope(&quot;singleton&quot;) public class UserDaoImpl implements UserDao { //此处省略代码 } 使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法 @PostConstruct public void init(){ System.out.println(&quot;初始化方法....&quot;); } @PreDestroy public void destroy(){ System.out.println(&quot;销毁方法.....&quot;); } 2.2 Spring新注解使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下： 非自定义的Bean的配置： 加载properties文件的配置：context:property-placeholder 组件扫描的配置：context:component-scan 引入其他文件： 注解 说明 @Configuration 用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解 @ComponentScan 用于指定 Spring 在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中的 &lt;context:component-scan base-package=”com.itheima”/&gt;一样 @Bean 使用在方法上，标注将该方法的返回值存储到 Spring 容器中 @PropertySource 用于加载.properties 文件中的配置 @Import 用于导入其他配置类 @Configuration @ComponentScan @Import @Configuration @ComponentScan(&quot;com.itheima&quot;) @Import({DataSourceConfiguration.class}) public class SpringConfiguration { } @PropertySource @value @PropertySource(&quot;classpath:jdbc.properties&quot;) public class DataSourceConfiguration { @Value(&quot;${jdbc.driver}&quot;) private String driver; @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String username; @Value(&quot;${jdbc.password}&quot;) private String password; @Bean @Bean(name=&quot;dataSource&quot;) public DataSource getDataSource() throws PropertyVetoException { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource; } 测试加载核心配置类创建Spring容器 @Test public void testAnnoConfiguration() throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfiguration.class); UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;); userService.save(); DataSource dataSource = (DataSource) applicationContext.getBean(&quot;dataSource&quot;); Connection connection = dataSource.getConnection(); System.out.println(connection); } 3. Spring整合Junit3.1 原始Junit测试Spring的问题在测试类中，每个测试方法都有以下两行代码： ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class); 这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。 3.2 上述问题解决思路让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它 将需要进行测试Bean直接在测试类中进行注入 3.3 Spring集成Junit步骤①导入spring集成Junit的坐标 ②使用@Runwith注解替换原来的运行期 ③使用@ContextConfiguration指定配置文件或配置类 ④使用@Autowired注入需要测试的对象 ⑤创建测试方法进行测试 3.4 Spring集成Junit代码实现①导入spring集成Junit的坐标 &lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; ②使用@Runwith注解替换原来的运行期 @RunWith(SpringJUnit4ClassRunner.class) public class SpringJunitTest { } ③使用@ContextConfiguration指定配置文件或配置类 @RunWith(SpringJUnit4ClassRunner.class) //加载spring核心配置文件 //@ContextConfiguration(value = {&quot;classpath:applicationContext.xml&quot;}) //加载spring核心配置类 @ContextConfiguration(classes = {SpringConfiguration.class}) public class SpringJunitTest { } ④使用@Autowired注入需要测试的对象 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = {SpringConfiguration.class}) public class SpringJunitTest { @Autowired private UserService userService; } ⑤创建测试方法进行测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = {SpringConfiguration.class}) public class SpringJunitTest { @Autowired private UserService userService; @Test public void testUserService(){ userService.save(); } } Spring集成Junit步骤 ①导入spring集成Junit的坐标 ②使用@Runwith注解替换原来的运行期 ③使用@ContextConfiguration指定配置文件或配置类 ④使用@Autowired注入需要测试的对象 ⑤创建测试方法进行测试","categories":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://lingdas.github.io/tags/springboot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}]},{"title":"AOP","slug":"AOP","date":"2021-06-14T01:42:14.000Z","updated":"2021-06-16T06:40:19.000Z","comments":true,"path":"2021/06/14/AOP/","link":"","permalink":"https://lingdas.github.io/2021/06/14/AOP/","excerpt":"","text":"1.Spring 的 AOP 简介1.1 什么是 AOPAOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 1.2 AOP 的作用及其优势作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 1.3 AOP 的底层实现实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 1.4 AOP 的动态代理技术常用的动态代理技术 JDK 代理 : 基于接口的动态代理技术 cglib 代理：基于父类的动态代理技术 1.5 JDK 的动态代理①目标类接口 public interface TargetInterface { public void method(); } ②目标类 public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); } } ③动态代理代码 Target target = new Target(); //创建目标对象 //创建代理对象 TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(target.getClass() .getClassLoader(),target.getClass().getInterfaces(),new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;前置增强代码...&quot;); Object invoke = method.invoke(target, args); System.out.println(&quot;后置增强代码...&quot;); return invoke; } } ); ④ 调用代理对象的方法测试 // 测试,当调用接口的任何方法时，代理对象的代码都无序修改 proxy.method(); 1.6 cglib 的动态代理①目标类 public class Target { public void method() { System.out.println(&quot;Target running....&quot;); } } ②动态代理代码 Target target = new Target(); //创建目标对象 Enhancer enhancer = new Enhancer(); //创建增强器 enhancer.setSuperclass(Target.class); //设置父类 enhancer.setCallback(new MethodInterceptor() { //设置回调 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(&quot;前置代码增强....&quot;); Object invoke = method.invoke(target, objects); System.out.println(&quot;后置代码增强....&quot;); return invoke; } }); Target proxy = (Target) enhancer.create(); //创建代理对象 ③调用代理对象的方法测试 //测试,当调用接口的任何方法时，代理对象的代码都无序修改 proxy.method(); 1.7 AOP 相关概念Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。 在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下： Target（目标对象）：代理的目标对象 Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点 Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义 Advice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知 Aspect（切面）：是切入点和通知（引介）的结合 Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入 1.8 AOP 开发明确的事项 1.8 AOP 开发明确的事项 1.8 AOP 开发明确的事项1)需要编写的内容 编写核心业务代码（目标类的目标方法） 编写切面类，切面类中有通知(增强功能方法) 在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合 2）AOP 技术实现的内容Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 3）AOP 底层使用哪种代理方式在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 1.9 知识要点 aop：面向切面编程 aop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理 aop的重点概念： Pointcut（切入点）：被增强的方法 Advice（通知/ 增强）：封装增强业务逻辑的方法 Aspect（切面）：切点+通知 Weaving（织入）：将切点与通知结合的过程 开发明确事项： 谁是切点（切点表达式配置） 谁是通知（切面类中的增强方法） 将切点和通知进行织入配置 2. 基于 XML 的 AOP 开发2.1 快速入门①导入 AOP 相关坐标 ②创建目标接口和目标类（内部有切点） ③创建切面类（内部有增强方法） ④将目标类和切面类的对象创建权交给 spring ⑤在 applicationContext.xml 中配置织入关系 ⑥测试代码 ①导入 AOP 相关坐标 &lt;!--导入spring的context坐标，context依赖aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aspectj的织入 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; ②创建目标接口和目标类（内部有切点） public interface TargetInterface { public void method(); } public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); } } ③创建切面类（内部有增强方法） public class MyAspect { //前置增强方法 public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } } ④将目标类和切面类的对象创建权交给 spring &lt;!--配置目标类--&gt; &lt;bean id=&quot;target&quot; class=&quot;com.itheima.aop.Target&quot;&gt;&lt;/bean&gt; &lt;!--配置切面类--&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;com.itheima.aop.MyAspect&quot;&gt;&lt;/bean&gt; ⑤在 applicationContext.xml 中配置织入关系 导入aop命名空间 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; ⑤在 applicationContext.xml 中配置织入关系 配置切点表达式和前置增强的织入关系 &lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(public void com.itheima.aop.Target.method())&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; ⑥测试代码 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class AopTest { @Autowired private TargetInterface target; @Test public void test1(){ target.method(); } } ⑦测试结果 2.2 XML 配置 AOP 详解1) 切点表达式的写法表达式语法： execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号* 代表任意 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表 例如： execution(public void com.itheima.aop.Target.method()) execution(void com.itheima.aop.Target.*(..)) execution(* com.itheima.aop.*.*(..)) execution(* com.itheima.aop..*.*(..)) execution(* *..*.*(..)) 2) 通知的类型通知的配置语法： &lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式&quot;&gt;&lt;/aop:通知类型&gt; 3) 切点表达式的抽取当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。 &lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.itheima.aop.*.*(..))&quot;/&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 2.3 知识要点 aop织入的配置 &lt;aop:config&gt; &lt;aop:aspect ref=“切面类”&gt; &lt;aop:before method=“通知方法名称” pointcut=“切点表达式&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知 切点表达式的写法： execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 3.基于注解的 AOP 开发3.1 快速入门基于注解的aop开发步骤： ①创建目标接口和目标类（内部有切点） ②创建切面类（内部有增强方法） ③将目标类和切面类的对象创建权交给 spring ④在切面类中使用注解配置织入关系 ⑤在配置文件中开启组件扫描和 AOP 的自动代理 ⑥测试 ①创建目标接口和目标类（内部有切点） public interface TargetInterface { public void method(); } public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); } } ②创建切面类（内部有增强方法) public class MyAspect { //前置增强方法 public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } } ③将目标类和切面类的对象创建权交给 spring @Component(&quot;target&quot;) public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); } } @Component(&quot;myAspect&quot;) public class MyAspect { public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } } ④在切面类中使用注解配置织入关系 @Component(&quot;myAspect&quot;) @Aspect public class MyAspect { @Before(&quot;execution(* com.itheima.aop.*.*(..))&quot;) public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } } ⑤在配置文件中开启组件扫描和 AOP 的自动代理 &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.itheima.aop&quot;/&gt; &lt;!--aop的自动代理--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; ⑥测试代码 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class AopTest { @Autowired private TargetInterface target; @Test public void test1(){ target.method(); } } ⑦测试结果 3.2 注解配置 AOP 详解1) 注解通知的类型通知的配置语法：@通知注解(“切点表达式”) 2) 切点表达式的抽取同 xml配置aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下： @@Component(&quot;myAspect&quot;) @Aspect public class MyAspect { @Before(&quot;MyAspect.myPoint()&quot;) public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } @Pointcut(&quot;execution(* com.itheima.aop.*.*(..))&quot;) public void myPoint(){} } 3.3 知识要点 注解aop开发步骤 ①使用@Aspect标注切面类 ②使用@通知注解标注通知方法 ③在配置文件中配置aop自动代理aop:aspectj-autoproxy/ 通知注解类型","categories":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://lingdas.github.io/tags/springboot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}]},{"title":"hexo的安装使用","slug":"hexo","date":"2021-06-14T01:42:14.000Z","updated":"2021-06-16T08:32:30.000Z","comments":true,"path":"2021/06/14/hexo/","link":"","permalink":"https://lingdas.github.io/2021/06/14/hexo/","excerpt":"","text":"安装hexonpm install hexo-cli -g hexo 使用方法生成hexo 官方的简单主题 hexo init 生成静态页面 hexo g 运行服务 hexo s 部署 npm install hexo-deployer-git --save hexo d 一键部署 hexo clean &amp;&amp; hexo g -d 用github做图床 访问的时候用这个链接加速 https://cdn.jsdelivr.net/gh/github的名字/项目名字/具体图片路径 如下面 我的名字是lingdas 项目是note 具体路径 /img/7.jpg https://cdn.jsdelivr.net/gh/lingdas/note/img/7.jpg 安装看版娘 npm install --save hexo-helper-live2d 模型下载 npm install live2d-widget-model-tsumiki 模型列表 live2d-widget-model-chitose live2d-widget-model-epsilon2_1 live2d-widget-model-gf live2d-widget-model-haru/01 live2d-widget-model-haru/02 live2d-widget-model-haruto live2d-widget-model-hibiki live2d-widget-model-hijiki live2d-widget-model-izumi live2d-widget-model-koharu live2d-widget-model-miku live2d-widget-model-ni-j live2d-widget-model-nico live2d-widget-model-nietzsche live2d-widget-model-nipsilon live2d-widget-model-nito live2d-widget-model-shizuku live2d-widget-model-tororo live2d-widget-model-tsumiki live2d-widget-model-unitychan live2d-widget-model-wanko live2d-widget-model-z16 模型配置（在根目录后面加上这个配置） # Live2D ## https://github.com/EYHN/hexo-helper-live2d live2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-haru scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 # use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url display: superSample: 2 width: 280 height: 480 position: right hOffset: 0 vOffset: -20 mobile: show: true # 是否在移动设备上显示 scale: 0.5 # 移动设备上的缩放 react: opacityDefault: 0.7 opacityOnHover: 0.8 在我们的Hexo根目录下新建一个live2d_models文件夹，注意：文件夹必须为该名字 把下载的模型复制到这个文件夹中 live2d_models","categories":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lingdas.github.io/tags/hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}]},{"title":"SpringIoC&DI","slug":"springboot笔记","date":"2021-06-14T00:46:12.000Z","updated":"2021-06-16T06:40:12.000Z","comments":true,"path":"2021/06/14/springboot笔记/","link":"","permalink":"https://lingdas.github.io/2021/06/14/springboot笔记/","excerpt":"","text":"1. spring概述1.1 Spring是什么（理解）Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。 提供了展现层 SpringMVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架 1.2 Spring发展历程 （了解）Rod Johnson （ Spring 之父） 2017 年9 月份发布了 Spring 的最新版本 Spring5.0通用版（GA） 1.3 Spring的优势（理解）方便解耦，简化开发 AOP 编程的支持 声明式事务的支持 方便程序的测试 1.4 Spring的体系结构（了解） 2. spring快速入门2.1 Spring程序开发步骤①导入 Spring 开发的基本包坐标 ②编写 Dao 接口和实现类 ③创建 Spring 核心配置文件 ④在 Spring 配置文件中配置 UserDaoImpl ⑤使用 Spring 的 API 获得 Bean 实例 2.2 导入Spring开发的基本包坐标&lt;properties&gt; &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.3 编写Dao接口和实现类public interface UserDao { public void save(); } public class UserDaoImpl implements UserDao { @Override public void save() { System.out.println(&quot;UserDao save method running....&quot;); } } 2.4 创建Spring核心配置文件在类路径下（resources）创建applicationContext.xml配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;/beans&gt; 2.5 在Spring配置文件中配置UserDaoImpl&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 2.6 使用Spring的API获得Bean实例@Test public void test1(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); } 3. Spring配置文件3.1 Bean标签基本配置用于配置对象交由Spring 来创建。 默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。 基本属性： id：Bean实例在Spring容器中的唯一标识 class：Bean的全限定名称 3.2 Bean标签范围配置scope:指对象的作用范围，取值如下： 取值范围 说明 singleton 默认值，单例的 prototype 多例的 request WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 request 域中 session WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 session 域中 global session WEB 项目中，应用在 Portlet 环境，如果没有 Portlet 环境那么globalSession 相当于 session 1）当scope的取值为singleton时 ​ Bean的实例化个数：1个 ​ Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例 ​ Bean的生命周期： 对象创建：当应用加载，创建容器时，对象就被创建了 对象运行：只要容器在，对象一直活着 对象销毁：当应用卸载，销毁容器时，对象就被销毁了 2）当scope的取值为prototype时 ​ Bean的实例化个数：多个 ​ Bean的实例化时机：当调用getBean()方法时实例化Bean 对象创建：当使用对象时，创建新的对象实例 对象运行：只要对象在使用中，就一直活着 对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了 3.3 Bean生命周期配置init-method：指定类中的初始化方法名称 destroy-method：指定类中销毁方法名称 3.4 Bean实例化三种方式1） 使用无参构造方法实例化 ​ 它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败 &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; 2） 工厂静态方法实例化 ​ 工厂的静态方法返回Bean实例 public class StaticFactoryBean { public static UserDao createUserDao(){ return new UserDaoImpl(); } } &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.StaticFactoryBean&quot; factory-method=&quot;createUserDao&quot; /&gt; 3） 工厂实例方法实例化 ​ 工厂的非静态方法返回Bean实例 public class DynamicFactoryBean { public UserDao createUserDao(){ return new UserDaoImpl(); } } &lt;bean id=&quot;factoryBean&quot; class=&quot;com.itheima.factory.DynamicFactoryBean&quot;/&gt; &lt;bean id=&quot;userDao&quot; factory-bean=&quot;factoryBean&quot; factory-method=&quot;createUserDao&quot;/&gt; 3.5 Bean的依赖注入入门①创建 UserService，UserService 内部在调用 UserDao的save() 方法 public class UserServiceImpl implements UserService { @Override public void save() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); } } ②将 UserServiceImpl 的创建权交给 Spring &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;/&gt; ③从 Spring 容器中获得 UserService 进行操作 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;); userService.save(); 3.6 Bean的依赖注入概念依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。 在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。 IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。 简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取 3.7 Bean的依赖注入方式①构造方法 ​ 创建有参构造 public class UserServiceImpl implements UserService { @Override public void save() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); } } ​ 配置Spring容器调用有参构造时进行注入 &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; ②set方法 ​ 在UserServiceImpl中添加setUserDao方法 public class UserServiceImpl implements UserService { private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void save() { userDao.save(); } } ​ 配置Spring容器调用set方法进行注入 &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; set方法:P命名空间注入 ​ P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下： ​ 首先，需要引入P命名空间： xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 其次，需要修改注入方式 &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot;/&gt; 3.8 Bean的依赖注入的数据类型上面的操作，都是注入的引用Bean，处了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。 注入数据的三种数据类型 普通数据类型 引用数据类型 集合数据类型 其中引用数据类型，此处就不再赘述了，之前的操作都是对UserDao对象的引用进行注入的，下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。 Bean的依赖注入的数据类型 （1）普通数据类型的注入 public class UserDaoImpl implements UserDao { private String company; private int age; public void setCompany(String company) { this.company = company; } public void setAge(int age) { this.age = age; } public void save() { System.out.println(company+&quot;===&quot;+age); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;company&quot; value=&quot;传智播客&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;&gt;&lt;/property&gt; &lt;/bean&gt; （2）集合数据类型（List）的注入 public class UserDaoImpl implements UserDao { private List&lt;String&gt; strList; public void setStrList(List&lt;String&gt; strList) { this.strList = strList; } public void save() { System.out.println(strList); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;strList&quot;&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; （3）集合数据类型（List）的注入 public class UserDaoImpl implements UserDao { private List&lt;User&gt; userList; public void setUserList(List&lt;User&gt; userList) { this.userList = userList; } public void save() { System.out.println(userList); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;u1&quot; class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean id=&quot;u2&quot; class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;userList&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean class=&quot;com.itheima.domain.User&quot;/&gt; &lt;ref bean=&quot;u1&quot;/&gt; &lt;ref bean=&quot;u2&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; （4）集合数据类型（ Map&lt;String,User&gt; ）的注入 public class UserDaoImpl implements UserDao { private Map&lt;String,User&gt; userMap; public void setUserMap(Map&lt;String, User&gt; userMap) { this.userMap = userMap; } public void save() { System.out.println(userMap); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;u1&quot; class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean id=&quot;u2&quot; class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;userMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;user1&quot; value-ref=&quot;u1&quot;/&gt; &lt;entry key=&quot;user2&quot; value-ref=&quot;u2&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; （5）集合数据类型（Properties）的注入 public class UserDaoImpl implements UserDao { private Properties properties; public void setProperties(Properties properties) { this.properties = properties; } public void save() { System.out.println(properties); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;p1&quot;&gt;aaa&lt;/prop&gt; &lt;prop key=&quot;p2&quot;&gt;bbb&lt;/prop&gt; &lt;prop key=&quot;p3&quot;&gt;ccc&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 3.9 引入其他配置文件（分模块开发）实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载 &lt;import resource=&quot;applicationContext-xxx.xml&quot;/&gt; 4. spring相关API4.1 ApplicationContext的继承体系applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象 4.2 ApplicationContext的实现类1）ClassPathXmlApplicationContext ​ 它是从类的根路径下加载配置文件 推荐使用这种 2）FileSystemXmlApplicationContext ​ 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 3）AnnotationConfigApplicationContext ​ 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 4.3 getBean()方法使用public Object getBean(String name) throws BeansException { assertBeanFactoryActive(); return getBeanFactory().getBean(name); } public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException { assertBeanFactoryActive(); return getBeanFactory().getBean(requiredType); } 其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。 当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错 getBean()方法使用 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService userService1 = (UserService) applicationContext.getBean(&quot;userService&quot;); UserService userService2 = applicationContext.getBean(UserService.class);","categories":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://lingdas.github.io/tags/springboot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://lingdas.github.io/categories/技术/"}]}]}