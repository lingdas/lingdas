{"meta":{"title":"lovelves","subtitle":null,"description":"光颖","author":"lovelves","url":"https://www.lovelves.cn"},"pages":[{"title":"about","date":"2021-06-12T14:14:36.000Z","updated":"2021-06-10T15:27:41.000Z","comments":false,"path":"about/index.html","permalink":"https://www.lovelves.cn/about/index.html","excerpt":"","text":"[lovelves的家] 与&nbsp; lovelves&nbsp; （ 龙傲天 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-06-21T13:51:19.118Z","comments":false,"path":"bangumi/index.html","permalink":"https://www.lovelves.cn/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"https://www.lovelves.cn/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"booklist","date":"2021-06-20T16:05:07.920Z","updated":"2021-06-20T16:05:07.920Z","comments":false,"path":"booklist/index.html","permalink":"https://www.lovelves.cn/booklist/index.html","excerpt":"","text":"学习笔记总结 spring学习1.1 spring xml配置1.2 spring注解配置1.3 spring AOP","keywords":"笔记总结"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"https://www.lovelves.cn/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"https://www.lovelves.cn/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"https://www.lovelves.cn/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"https://www.lovelves.cn/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-06-20T14:26:37.289Z","comments":false,"path":"music/index.html","permalink":"https://www.lovelves.cn/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"links/index.html","permalink":"https://www.lovelves.cn/links/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://www.lovelves.cn/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"https://www.lovelves.cn/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.lovelves.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"macOS技巧","slug":"macOS技巧","date":"2021-07-17T04:27:31.000Z","updated":"2021-07-17T04:29:23.451Z","comments":true,"path":"2021/07/17/macOS技巧/","link":"","permalink":"https://www.lovelves.cn/2021/07/17/macOS技巧/","excerpt":"","text":"关闭macOs 中烦人的更新步骤 1到「应用程式」&gt;「工具程式」内开启「终端机」。步骤 2开启终端机（Terminal）后，复制底下指令后按「Enter」执行，过程中会需要你输入管理者密码才能执行，输入完毕后重新开机一次即可。 sudo softwareupdate --ignore &quot;macOS Catalina&quot; sudo softwareupdate --ignore &quot;macOS big sur&quot; 步骤 3继续复制底下指令，直接贴上终端机后按「Enter」执行。 defaults delete com.apple.preferences.softwareupdate 步骤 4最后执行底下指令，执行结果会显示macOS Catalina 10.15.5 不建议关闭系统更新，不过其实输入指令后也同样是可以强制关闭。 softwareupdate --list 步骤 5完成以上步骤后，最后还是会发现有红色提示macOS 更新讯息，最后要更新缓存。 defaults delete com.apple.systempreferences AttentionPrefBundleIDs; killall Dock","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"macOS技巧","slug":"macOS技巧","permalink":"https://www.lovelves.cn/tags/macOS技巧/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"人工智能实战学习01","slug":"人工智能实战学习01","date":"2021-07-10T15:15:59.000Z","updated":"2021-07-17T04:30:45.215Z","comments":true,"path":"2021/07/10/人工智能实战学习01/","link":"","permalink":"https://www.lovelves.cn/2021/07/10/人工智能实战学习01/","excerpt":"","text":"人工智能学习课程之（环境准备）安装pythonhttps://www.python.org/downloads/安装condahttps://www.anaconda.com/products/individual在anaconda中创建新的环境 输入命令 创建一个环境 名字叫ai conda create -n ai 然后激活环境 conda activate ai 然后按装jupyterjupyter界面优化 pip install jupyterthemes jt -t grade3 -f fira -fs 16 -cellw 90% -ofs 11 -dfs 11 -T 安装pandas pip install pandas -i https://pypi.douban.com/simple 安装matplotlib pip install matplotlib -i https://pypi.douban.com/simple 安装sklearn pip install sklearn -i https://pypi.douban.com/simple 人工智能学习课程之（线性回归模型）引入pandas库 把数据引入(2.csv)的数据如下x,y1, 72, 93, 114, 135, 156, 177, 198, 219, 2310, 25 数据引入阶段 import pandas as pd import numpy as np data=pd.read_csv(&#39;2.csv&#39;) #把2.csv文件的数据读入到data中 data.head() # 查看数据前几行 print(type(data),data.shape) #查看数据的类型 和 维度 &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; (10, 2) x = data.loc[:,&#39;x&#39;] #把数据中的x列读入到x中 y = data.loc[:,&#39;y&#39;] #把数据中的x列读入到y中 x=np.array(x).reshape(-1,1) #把数据转换为二维 y=np.array(y).reshape(-1,1) #把数据转换为二维 数据展示阶段 from matplotlib import pyplot as plt plt.figure(figsize=(10,10)) #创建10*10大小的画板 plt.scatter(x,y) #画散点图 plt.show() # 展示图片 数据分析阶段 import sklearn from sklearn.linear_model import LinearRegression # 引入线性回归模型 l_model = LinearRegression()# 初始化线性回归模型 l_model.fit(x,y)#把数据丢给模型处理 y_predict = l_model.predict(x) # 预测数据通过给x 预测y的值 y_predict = l_model.predict([[2.5]]) # 预测数据通过给x=2.5 预测y的值 a=l_model.coef_ # 求出线性中a的值 y=ax+b b=l_model.intercept_ # 求出线性中b的值 y=ax+b print(a,b) #[[2.]] [5.] 判断模型建立的好不好 from sklearn.metrics import mean_squared_error,r2_score mse = mean_squared_error(y,y_predict) # mse的值越小越好 r2 = r2_score(y,y_predict) # r2的值越接近1越好 print(mse,r2) # 3.1554436208840474e-31 1.0","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://www.lovelves.cn/tags/人工智能/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"python图形界面学习","slug":"python图形界面学习","date":"2021-06-26T11:37:42.000Z","updated":"2021-07-01T12:02:27.302Z","comments":true,"path":"2021/06/26/python图形界面学习/","link":"","permalink":"https://www.lovelves.cn/2021/06/26/python图形界面学习/","excerpt":"","text":"pyside2 学习虚拟环境准备安装虚拟环境 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple virtualenv 虚拟环境的使用创建虚拟环境（会多了一个目录名字叫venv） virtualenv venv 激活虚拟环境（进入虚拟环境 正常的通过命令pip 安装自己需要的包 安装的包存放在venv中的lib/python/site-packages中） mac下执行以下命令我的venv的位置在根目录 执行以下命令 source venv/bin/activate windows下 直接用命令行窗口定位到venv\\Scripts\\ 执行以下命令 activate 退出虚拟环境（退出虚拟环境） deactivate pyside2 安装pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyside2 第一个pyside2小案例 from PySide2.QtWidgets import QApplication, QMainWindow, QPushButton, QPlainTextEdit app = QApplication([]) #QApplication 提供了整个图形界面程序的底层管理功能 window = QMainWindow() #创建Windows控件 window.resize(500, 400) #定义窗口大小 window.move(300, 310) #定义窗口的位置 window.setWindowTitle(&#39;薪资统计&#39;) # 定义窗口的标题 textEdit = QPlainTextEdit(window) #创建文本编辑框 textEdit.setPlaceholderText(&quot;请输入薪资表&quot;) #显示默认语句 textEdit.move(10,25) textEdit.resize(300,350) button = QPushButton(&#39;统计&#39;, window) #创建按钮 button.move(380,80) window.show() #显示窗口 app.exec_() # 进入QApplication的事件处理循环，接收用户的输入事件（），并且分配给相应的对象去处理 统计按钮的事件绑定 def handleCalc(): print(&#39;统计按钮被点击了&#39;) button.clicked.connect(handleCalc) #用户点击按钮的时候触发handlecalc方法 获取编辑框的文本(toPlainText) text = edit.toPlainText() from PySide2.QtWidgets import QApplication, QMainWindow, QPushButton, QPlainTextEdit,QMessageBox class Stats(): def __init__(self): self.window = QMainWindow() self.window.resize(500, 400) self.window.move(300, 300) self.window.setWindowTitle(&#39;薪资统计&#39;) self.textEdit = QPlainTextEdit(self.window) self.textEdit.setPlaceholderText(&quot;请输入薪资表&quot;) self.textEdit.move(10, 25) self.textEdit.resize(300, 350) self.button = QPushButton(&#39;统计&#39;, self.window) self.button.move(380, 80) self.button.clicked.connect(self.handleCalc) def handleCalc(self): info = self.textEdit.toPlainText() # 薪资20000 以上 和 以下 的人员名单 salary_above_20k = &#39;&#39; salary_below_20k = &#39;&#39; for line in info.splitlines(): if not line.strip(): continue parts = line.split(&#39; &#39;) # 去掉列表中的空字符串内容 parts = [p for p in parts if p] name,salary,age = parts if int(salary) &gt;= 20000: salary_above_20k += name + &#39;\\n&#39; else: salary_below_20k += name + &#39;\\n&#39; QMessageBox.about(self.window, &#39;统计结果&#39;, f&#39;&#39;&#39;薪资20000 以上的有：\\n{salary_above_20k} \\n薪资20000 以下的有：\\n{salary_below_20k}&#39;&#39;&#39; ) app = QApplication([]) stats = Stats() stats.window.show() app.exec_() 用Designer来编辑窗口界面前面的代码都是手动定义按键的位置的 这样太麻烦了 我们可以用界面设计师来完成界面的设计 我是用虚拟环境安装的 安装了pyside2后 在site-packages中的pyside2文件中会找到 打开的界面如下 把要用到的组件往界面拖就是了 很简单当你把组件放上去 你会发现 有些很难对齐 即使对齐了 界面拖到后 不会自动改变自己的大小 这时候我们就用到布局 Qt是通过界面布局Layout类来实现这种功能的。我们最常用的 Layout布局 有4种，分别是QHBoxLayout 水平布局QHBoxLayout 把控件从左到右 水平横着摆放QVBoxLayout 垂直布局QHBoxLayout 把控件从上到下竖着摆放 QGridLayout 栅格布局QGridLayout 把多个控件 按表格布局 对界面布局的一些建议先不使用任何layout，所有控件按自己喜欢的位置往上摆然后在从内层开始布局 在到外层最后通过layout控件大小比例来控制位置layoutstrentch 设置好后保存后 会有一个UI文件 用python代码来加载刚创建的ui文件加载界面文件 ui = QUiLoader().load(&#39;m.ui&#39;) 里面的控件对象也成为窗口对象的属性了 可以通过代码定位到组件 比如我想把按钮添加一个方法 ui.pushButton.clicked.connect(self.handleCalc) 属性叫什么名字 都是自己定义的 比如这个按钮就是 ui.pushButton_5 一个小的案例 from PySide2.QtWidgets import QApplication, QMessageBox from PySide2.QtUiTools import QUiLoader class Stats: def __init__(self): # 从文件中加载UI定义 # 从 UI 定义中动态 创建一个相应的窗口对象 # 注意：里面的控件对象也成为窗口对象的属性了 # 比如 self.ui.button , self.ui.textEdit self.ui = QUiLoader().load(&#39;m.ui&#39;) self.ui.pushButton.clicked.connect(self.handleCalc) def handleCalc(self): info = self.ui.plainTextEdit.toPlainText() salary_above_20k = &#39;&#39; salary_below_20k = &#39;&#39; for line in info.splitlines(): if not line.strip(): continue parts = line.split(&#39; &#39;) parts = [p for p in parts if p] name,salary,age = parts if int(salary) &gt;= 20000: salary_above_20k += name + &#39;\\n&#39; else: salary_below_20k += name + &#39;\\n&#39; QMessageBox.about(self.ui, &#39;统计结果&#39;, f&#39;&#39;&#39;薪资20000 以上的有：\\n{salary_above_20k} \\n薪资20000 以下的有：\\n{salary_below_20k}&#39;&#39;&#39; ) app = QApplication([]) stats = Stats() stats.ui.show() app.exec_() 常用组件QPushButton 按钮被点击 pushButton.clicked.connect(handleCalc) #handleCalc是一个方法的名字 负责处理点击后执行的内容 改变按键的的文本 pushButton.setText(text) #text 字符串 要定义的文本 把按键禁用和启用 pushButton.setEnabled(False) #禁用 pushButton.setEnabled(True) #启用 单行文本框文本被修改当文本框中的内容被键盘编辑，被点击就会发出 textChanged 信号，可以这样指定处理该信号的函数 edit.textChanged.connect(handleTextChange) #handleTextChange 是一个方法的名字 负责处理 按下回车键当用户在文本框中任何时候按下回车键，就会发出 returnPressed 信号 passwordEdit.returnPressed.connect(onLogin) # onLogin 是一个方法的名字 负责处理 获取文本通过 text 方法获取编辑框内的文本内容，比如 text = edit.text() 设置提示通过 setPlaceholderText 方法可以设置提示文本内容，比如 edit.setPlaceholderText(&#39;请在这里输入URL&#39;) 设置文本 edit.setText(&#39;填入你要写的文本&#39;) 清除所有文本 edit.clear() 拷贝文本到剪贴板 edit.copy() 粘贴剪贴板文本 edit.paste() 多行纯文本框QPlainTextEdit 是可以 多行 的纯文本编辑框注意：在苹果MacOS上，有 更新文本框内容后，需要鼠标滑过才能更新显示的bug 文本被修改当文本框中的内容被键盘编辑，被点击就会发出 textChanged 信号，可以这样指定处理该信号的函数 edit.textChanged.connect(handleTextChange) 光标位置改变当文本框中的光标位置变动，就会发出 cursorPositionChanged 信号，可以这样指定处理该信号的函数 edit.cursorPositionChanged.connect(handleChanged) 获取文本通过 toPlainText 方法获取编辑框内的文本内容，比如 text = edit.toPlainText() 获取选中文本 # 获取 QTextCursor 对象 textCursor = edit.textCursor() selection = textCursor.selectedText() 设置提示 edit.setPlaceholderText(&#39;请在这里输入&#39;) 设置文本通过 setPlainText 方法设置编辑框内的文本内容 为参数里面的文本字符串，比如 edit.setPlainText(&#39;hello&#39;)# 原来的所有内容会被清除 在末尾添加文本通过 appendPlainText 方法在编辑框末尾添加文本内容，比如 edit.appendPlainText(&#39;末尾添加文本内容&#39;) # 注意：这种方法会在添加文本后 自动换行 在光标处插入文本通过 insertPlainText 方法在编辑框末尾添加文本内容，比如 edit.insertPlainText(&#39;末尾添加文本内容&#39;) # 注意：这种方法 不会 在添加文本后自动换行 清除所有文本clear 方法可以清除编辑框内所有的文本内容，比如 edit.clear() 拷贝文本到剪贴板copy 方法可以拷贝当前选中文本到剪贴板，比如 edit.copy() 粘贴剪贴板文本paste 方法可以把剪贴板内容，拷贝到编辑框当前光标所在处，比如 edit.paste() 文本浏览框QTextBrowser 是 只能查看文本 控件。通常用来显示一些操作日志信息、或者不需要用户编辑的大段文本内容。该控件 获取文本、设置文本、清除文本、剪贴板复制粘贴 等等， 都和上面介绍的 多行纯文本框是一样的。 在末尾添加文本通过 append 方法在编辑框末尾添加文本内容，比如 textBrowser.append(&#39;末尾添加文本内容&#39;) 有时，浏览框里面的内容长度超出了可见范围，我们在末尾添加了内容，往往希望控件自动翻滚到当前添加的这行，可以通过 ensureCursorVisible 方法来实现 textBrowser.append(&#39;末尾添加文本内容&#39;) textBrowser.ensureCursorVisible() #注意：这种方法会在添加文本后 自动换行 在光标处插入文本通过 insertPlainText 方法在编辑框末尾添加文本内容，比如 edit.insertPlainText(&#39;添加文本内容&#39;) # 这种方法 不会 在添加文本后自动换行 标签QLabel 就是常见的标签，可以用来显示文字（包括纯文本和富文本）、图片 甚至动画 改变文本代码中可以使用 setText 方法来改变标签文本内容，比如 button.setText(text) 图片QLabel可以用来显示图片，有时一个图片可以让界面好看很多，可以在 Qt Designer上 属性编辑器 QLabel 栏 的 pixmap 属性设置中选择图片文件指定。 组合选择框 选项改变如果用户操作修改了QComboBox中的选项就会发出 currentIndexChanged 信号，可以这样指定处理该信号的函数 cbox.currentIndexChanged.connect(handleSelectionChange) 添加一个选项代码中可以使用 addItem 方法来添加一个选项到 末尾 ，参数就是选项文本 cbox.addItem(&#39;byhy&#39;) 添加多个选项代码中可以使用 addItems 方法来添加多个选项到 末尾，参数是包含了多个选项文本的列表 cbox.addItems([&#39;java&#39;,&#39;c++&#39;,&#39;python教程&#39;]) 清空选项代码中可以使用 clear 方法来清空选项，也就是删除选择框内所有的选项 cbox.clear() 获取当前选项文本代码中可以使用 currentText 方法来获取当前 选中的选项 的文本，比如 method = cbox.currentText() 列表QListWidget 是列表控件，如下图所示 添加一个选项代码中可以使用 addItem 方法来添加一个选项到 末尾 ，参数就是选项文本 listWidget.addItem(&#39;helo&#39;) 添加多个选项代码中可以使用 addItems 方法来添加多个选项到 末尾，参数是包含了多个选项文本的列表 listWidget.addItems([&#39;go&#39;,&#39;java&#39;,&#39;python教程&#39;]) 删除一个选项代码中可以使用 takeItem 方法来删除1个选项，参数是该选项所在行 listWidget.takeItem(1) #就会删除第二行选项 清空选项代码中可以使用 clear 方法来清空选项，也就是删除选择框内所有的选项 listWidget.clear() 获取当前选项文本currentItem 方法可以得到列表当前选中项对象（QListWidgetItem） ，再调用这个对象的 text 方法，就可以获取文本内容，比如 listWidget.currentItem().text() # 就获取了 第1行，第1列 的单元格里面的文本。 表格QTableWidget 是表格控件，如下图所示 创建列 和 标题栏我们可以通过 Qt designer 为一个表格创建列和对应的标题栏。只需要双击 Qt designer 设计的窗体中的 表格控件， 就会出现这样的对话框。 插入一行、删除一行insertRow 方法可以在指定位置插入一行，比如 table.insertRow(0) # 就插入一行到第 1 行这个位置， 表格原来第1行（包括原来的第1行）以后的内容，全部往下移动一行。 removeRow 方法可以删除指定位置的一行，比如 table.removeRow(0) # 就插入一行到第 1 行这个位置， 表格原来第1行（包括原来的第1行）以后的内容，全部往下移动一行。 设置单元格文本内容qt表格的单元格内的内容对象 是一个 单元格对象 QTableWidgetItem 实例如果单元格 没有被设置过 内容，可以这样 from PySide2.QtWidgets import QTableWidgetItem table.setItem(0, 0, QTableWidgetItem(&#39;hello&#39;))# 0行0列添加文本hello 如果希望某个单元格为 只读，不允许修改，可以使用QTableWidgetItem对象的 setFlags 方法，像这样 from PySide2.QtWidgets import QTableWidgetItem from PySide2.QtCore import Qt item = QTableWidgetItem(&#39;hello&#39;) item.setFlags(Qt.ItemIsEnabled) # 参数名字段不允许修改 table.setItem(row, 0, item) 如果想文本内容 居中对齐，每个当对应的QTableWidgetItem 调用 setTextAlignment，如下 from PySide2.QtWidgets import QTableWidgetItem from PySide2.QtCore import Qt item = QTableWidgetItem() item.setText(&#39;hello&#39;) # 文本居中 item.setTextAlignment(Qt.AlignHCenter) table.setItem(row, 0, item) 获取单元格文本的内容item 方法可以指定位置的单元格对象（QTableWidgetItem） ，再调用这个对象的 text 方法，就可以获取文本内容，比如 table.item(0,0).text() 获取所有行数、列数代码中可以使用 rowCount 方法来获取表格所有的 行数 ，比如 rowcount = table.rowCount() 可以使用 columnCount 方法来获取表格所有的 列数 ，比如 rowcount = table.columnCount() 获取当前选中是第几行代码中可以使用 currentRow 方法来获取当前选中是第几行，比如 currentrow = table.currentRow() 获取选中的行的内容 table.selectedItems() 设置表格行数、列数代码中可以使用 setRowCount 方法来设置表格 行数 ，比如 table.setRowCount(10) 代码中可以使用 setColumnCount 方法来设置表格 列数 ，比如 table.setColumnCount(10) 清除/删除所有内容clearContents 方法可以清除表格所有的内容，比如 table.clearContents() 清除后，仍然会留下表格栏如果连表格栏都要删除，可以使用 setRowCount(0)，像这样 table.setRowCount(0) 设定列宽、宽度自动缩放Qt Designer 上目前没法拖拽设定 每个列的宽度，只能在代码中指定。 #设定第1列的宽度为 180像素 table.setColumnWidth(0, 180) #设定第2列的宽度为 100像素 table.setColumnWidth(1, 100) 如想让 表格控件宽度 随着父窗口的缩放自动缩放，可以 table.horizontalHeader().setStretchLastSection(True) 单元格内容改动当用户修改了一个单元格的内容，会发出 cellChanged 信号，并且携带参数指明该单元格的行号和列号。我们的代码可以对该信号进行相应的处理。示例代码如下 def __init__(self): # 指定单元格改动信号处理函数 self.ui.table.cellChanged.connect(self.cfgItemChanged) def cfgItemChanged(self,row,column): # 获取更改内容 cfgName = self.ui.table.item(row, 0).text() # 首列为配置名称 cfgValue = self.ui.table.item(row, column).text()","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"python图形界面","slug":"python图形界面","permalink":"https://www.lovelves.cn/tags/python图形界面/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"编程的方法（编辑中）","slug":"编程思想","date":"2021-06-25T15:46:54.000Z","updated":"2021-07-05T14:08:06.715Z","comments":true,"path":"2021/06/25/编程思想/","link":"","permalink":"https://www.lovelves.cn/2021/06/25/编程思想/","excerpt":"","text":"编程思想的学习最垃圾的代码(第一版)main 主方法 package test; import awkward.hero.Camille; import awkward.hero.Diana; import awkward.hero.Lrelia; import java.util.Scanner; public class Main { public static void main(String[] args) { String name = Main.getPlayerInput(); switch (name){ case &quot;Camille&quot;: Camille camille = new Camille(); camille.r(); break; case &quot;Lrelia&quot;: Lrelia lrelia = new Lrelia(); lrelia.r(); break; case &quot;Diana&quot;: Diana diana = new Diana(); diana.r(); break; } } private static String getPlayerInput(){ System.out.println(&quot;enter a hero name:&quot;); Scanner scanner = new Scanner(System.in); return scanner.nextLine(); } } 各个英雄的方法 package awkward.hero; public class Camille { public void r(){ System.out.println(&quot;camille r&quot;); } } package awkward.hero; public class Diana { public void r(){ System.out.println(&quot;Diana r&quot;); } } package awkward.hero; public class Lrelia { public void r(){ System.out.println(&quot;Lrelia r&quot;); } } 最垃圾的代码（第二版）运用面向对象中interface 接口main主方法 package test; import awkward.hero.Camille; import awkward.hero.Diana; import awkward.hero.Hero; import awkward.hero.Lrelia; import java.util.Scanner; public class Main { public static void main(String[] args) { String name = Main.getPlayerInput(); Hero hero =null; switch (name){ case &quot;Camille&quot;: hero = new Camille(); break; case &quot;Lrelia&quot;: hero = new Lrelia(); break; case &quot;Diana&quot;: hero = new Diana(); break; } hero.r(); } private static String getPlayerInput(){ System.out.println(&quot;enter a hero name:&quot;); Scanner scanner = new Scanner(System.in); return scanner.nextLine(); } } 各个英雄的方法 package awkward.hero; public interface Hero { public void r(); } package awkward.hero; public class Camille implements Hero{ public void r(){ System.out.println(&quot;camille r&quot;); } } package awkward.hero; public class Diana implements Hero{ public void r(){ System.out.println(&quot;Diana r&quot;); } } package awkward.hero; public class Lrelia implements Hero{ public void r(){ System.out.println(&quot;Lrelia r&quot;); } } 结论接口 只统一了方法的调用 不能统一对象的实例化面向对象只做了两件事情 实例化对象 调用方法 （完成业务逻辑）要保持一段代码的稳定性 这段代码就不应该负责对象的实例化（不应该出现new关键字）所以对象的实例化过程要转移到其他代码片段里 最垃圾的代码（第三版）把对象实例化的过程转移到其他代码片段中 代码总是有不稳定的 把不稳定的代码隔离 保证其他代码稳定main方法 package test; import awkward.Factory; import awkward.hero.Hero; import java.util.Scanner; public class Main { public static void main(String[] args) { String name = Main.getPlayerInput(); Hero hero = Factory.getHero(name); hero.r(); } private static String getPlayerInput(){ System.out.println(&quot;enter a hero name:&quot;); Scanner scanner = new Scanner(System.in); return scanner.nextLine(); } } 工厂方法 package awkward; import awkward.hero.Camille; import awkward.hero.Diana; import awkward.hero.Hero; import awkward.hero.Lrelia; public class Factory { public static Hero getHero(String name){ Hero hero = null; switch (name){ case &quot;Camille&quot;: hero = new Camille(); break; case &quot;Lrelia&quot;: hero = new Lrelia(); break; case &quot;Diana&quot;: hero = new Diana(); break; } return hero; } } 各个英雄方法 package awkward.hero; public interface Hero { public void r(); } package awkward.hero; public class Camille implements Hero{ public void r(){ System.out.println(&quot;camille r&quot;); } } package awkward.hero; public class Diana implements Hero{ public void r(){ System.out.println(&quot;Diana r&quot;); } } package awkward.hero; public class Lrelia implements Hero{ public void r(){ System.out.println(&quot;Lrelia r&quot;); } } 最垃圾的代码（第四版）在第三版的基础上改进 应用反射只修改第三版的工厂方法 package awkward; import awkward.hero.Camille; import awkward.hero.Diana; import awkward.hero.Hero; import awkward.hero.Lrelia; import java.lang.reflect.InvocationTargetException; public class Factory { public static Hero getHero(String name) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { name = &quot;awkward.hero.&quot;+name; Class&lt;?&gt; cls = Class.forName(name); Object obj = cls.getDeclaredConstructor().newInstance(); return (Hero) obj; } } 总结前面演示的几版代码中 程序是变化的 是用户输入的变化 还是需求的变化 这些都是不稳定的因素 把不稳定的因素尽量放在一起 后续可维护性大大提高 spring 中的ioc 控制反转 把对象的创建 装配 等操作 都交给spring容器来处理 就相当于现实生活中 spring就是一个生成积木的厂家 他只负责生成积木 至于积木如何搭配形状 这些它不考虑只给购买积木的人去考虑 至于搭成什么样形状的积木由购买积木的人决定 控制反转 就是 把主控权交给用户 最为代表性的是spring中的di 依赖注入","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"编程方法","slug":"编程方法","permalink":"https://www.lovelves.cn/tags/编程方法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"js的逆向学习","slug":"js的逆向学习","date":"2021-06-21T13:15:27.000Z","updated":"2021-06-21T13:17:15.351Z","comments":true,"path":"2021/06/21/js的逆向学习/","link":"","permalink":"https://www.lovelves.cn/2021/06/21/js的逆向学习/","excerpt":"","text":"JS的解析学习目标： 了解 定位js的方法 了解 添加断点观察js的执行过程的方法 应用 js2py获取js的方法 1 确定js的位置 对于前面人人网的案例，我们知道了url地址中有部分参数，但是参数是如何生成的呢？ 毫无疑问，参数肯定是js生成的，那么如何获取这些参数的规律呢？通过下面的学习来了解 1.1 观察按钮的绑定js事件 通过点击按钮，然后点击Event Listener，部分网站可以找到绑定的事件，对应的，只需要点击即可跳转到js的位置 1.2 通过search all file 来搜索部分网站的按钮可能并没有绑定js事件监听，那么这个时候可以通过搜索请求中的关键字来找到js的位置，比如livecell 点击美化输出选项 可以继续在其中搜索关键字 2 观察js的执行过程找到js的位置之后，我们可以来通过观察js的位置，找到js具体在如何执行，后续我们可以通过python程序来模拟js的执行，或者是使用类似js2py直接把js代码转化为python程序去执行 观察js的执行过程最简单的方式是添加断点 添加断点的方式：在左边行号点击即可添加，对应的右边BreakPoints中会出现现有的所有断点 添加断点之后继续点击登录，每次程序在断点位置都会停止，通过如果该行有变量产生，都会把变量的结果展示在Scoope中 在上图的右上角有1，2，3三个功能，分别表示： - 1：继续执行到下一个断点 - 2：进入调用的函数中 - 3：从调用的函数中跳出来 3 js2py的使用 在知道了js如何生成我们想要的数据之后，那么接下来我们就需要使用程序获取js执行之后的结果了 3.1 js2py的介绍js2py是一个js的翻译工具，也是一个通过纯python实现的js的解释器，github上源码与示例 3.2 js的执行思路js的执行方式大致分为两种： 在了解了js内容和执行顺序之后，通过python来完成js的执行过程，得到结果 在了解了js内容和执行顺序之后，使用类似js2py的模块来执js代码，得到结果 但是在使用python程序实现js的执行时候，需要观察的js的每一个步骤，非常麻烦，所以更多的时候我们会选择使用类似js2py的模块去执行js，接下来我们来使用js2py实现人人网登录参数的获取 3.3 具体的实现定位进行登录js代码 formSubmit: function() { var e, t = {}; $(&quot;.login&quot;).addEventListener(&quot;click&quot;, function() { t.phoneNum = $(&quot;.phonenum&quot;).value, t.password = $(&quot;.password&quot;).value, e = loginValidate(t), t.c1 = c1 || 0, e.flag ? ajaxFunc(&quot;get&quot;, &quot;http://activity.renren.com/livecell/rKey&quot;, &quot;&quot;, function(e) { var n = JSON.parse(e).data; if (0 == n.code) { t.password = t.password.split(&quot;&quot;).reverse().join(&quot;&quot;), setMaxDigits(130); var o = new RSAKeyPair(n.e,&quot;&quot;,n.n) , r = encryptedString(o, t.password); t.password = r, t.rKey = n.rkey } else toast(&quot;公钥获取失败&quot;), t.rKey = &quot;&quot;; ajaxFunc(&quot;post&quot;, &quot;http://activity.renren.com/livecell/ajax/clog&quot;, t, function(e) { var e = JSON.parse(e).logInfo; 0 == e.code ? location.href = localStorage.getItem(&quot;url&quot;) || &quot;&quot; : toast(e.msg || &quot;登录出错&quot;) }) }) : toast(e.msg) }) } 从代码中我们知道: 我们要登录需要对密码进行加密和获取rkey字段的值 rkey字段的值我们直接发送请求rkey请求就可以获得 密码是先反转然后使用RSA进行加密, js代码很复杂, 我们希望能通过在python中执行js来实现 实现思路: 使用session发送rKey获取登录需要信息 url: http://activity.renren.com/livecell/rKey 方法: get 根据获取信息对密码进行加密 2.1 准备用户名和密码 2.2 使用js2py生成js的执行环境:context 2.3 拷贝使用到js文件的内容到本项目中 2.4 读取js文件的内容,使用context来执行它们 2.5 向context环境中添加需要数据 2.6 使用context执行加密密码的js字符串 2.7 通过context获取加密后密码信息 使用session发送登录请求 URL: http://activity.renren.com/livecell/ajax/clog 请求方法: POST 数据: phoneNum: xxxxxxx password: (加密后生产的) c1: 0 rKey: rkey请求获取的 具体代码需要提前下载几个js文件到本地： BigInt.js RSA.js Barrett.js import requests import json import js2py # - 实现思路: # - 使用session发送rKey获取登录需要信息 # - url: http://activity.renren.com/livecell/rKey # - 方法: get # 获取session对象 session = requests.session() headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Mobile Safari/537.36&quot;, &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;, &quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot; } # 设置session的请求头信息 session.headers = headers response = session.get(&quot;http://activity.renren.com/livecell/rKey&quot;) # print(response.content.decode()) n = json.loads(response.content)[&#39;data&#39;] # - 根据获取信息对密码进行加密 # - 准备用户名和密码 phoneNum = &quot;131...&quot; password = &quot;****&quot; # - 使用js2py生成js的执行环境:context context = js2py.EvalJs() # - 拷贝使用到js文件的内容到本项目中 # - 读取js文件的内容,使用context来执行它们 with open(&quot;BigInt.js&quot;, &#39;r&#39;, encoding=&#39;utf8&#39;) as f: context.execute(f.read()) with open(&quot;RSA.js&quot;, &#39;r&#39;, encoding=&#39;utf8&#39;) as f: context.execute(f.read()) with open(&quot;Barrett.js&quot;, &#39;r&#39;, encoding=&#39;utf8&#39;) as f: context.execute(f.read()) # - 向context环境中添加需要数据 context.t = {&#39;password&#39;: password} context.n = n # - 执行加密密码的js字符 js = &#39;&#39;&#39; t.password = t.password.split(&quot;&quot;).reverse().join(&quot;&quot;), setMaxDigits(130); var o = new RSAKeyPair(n.e,&quot;&quot;,n.n) , r = encryptedString(o, t.password); &#39;&#39;&#39; context.execute(js) # - 通过context获取加密后密码信息 # print(context.r) password = context.r # - 使用session发送登录请求 # - URL: http://activity.renren.com/livecell/ajax/clog # - 请求方法: POST # - 数据: # - phoneNum: 15565280933 # - password: (加密后生产的) # - c1: 0 # - rKey: rkey请求获取的 data = { &#39;phoneNum&#39;: &#39;131....&#39;, &#39;password&#39;: password, &#39;c1&#39;:0, &#39;rKey&#39;:n[&#39;rkey&#39;] } # print(session.headers) response = session.post(&quot;http://activity.renren.com/livecell/ajax/clog&quot;, data=data) print(response.content.decode()) # 访问登录的资源 response = session.get(&quot;http://activity.renren.com/home#profile&quot;) print(response.content.decode()) 小结 通过在chrome中观察元素的绑定事件可以确定js 通过在chrome中search all file 搜索关键字可以确定js的位置 观察js的数据生成过程可以使用添加断点的方式观察 js2py的使用 需要准备js的内容 生成js的执行环境 在执行环境中执行js的字符串，传入数据，获取结果","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.lovelves.cn/tags/爬虫/"},{"name":"python","slug":"python","permalink":"https://www.lovelves.cn/tags/python/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"爬虫学习之旅03-chrome浏览器的使用","slug":"爬虫之浏览器的使用","date":"2021-06-21T13:09:48.000Z","updated":"2021-06-21T13:13:28.023Z","comments":true,"path":"2021/06/21/爬虫之浏览器的使用/","link":"","permalink":"https://www.lovelves.cn/2021/06/21/爬虫之浏览器的使用/","excerpt":"","text":"chrome浏览器使用方法介绍学习目标 了解 新建隐身窗口的目的 了解 chrome中network的使用 了解 寻找登录接口的方法 1 新建隐身窗口 浏览器中直接打开网站，会自动带上之前网站时保存的cookie，但是在爬虫中首次获取页面是没有携带cookie的，这种情况如何解决呢？ 使用隐身窗口，首次打开网站，不会带上cookie，能够观察页面的获取情况，包括对方服务器如何设置cookie在本地 2 chrome中network的更多功能 2.1 Perserve log默认情况下，页面发生跳转之后，之前的请求url地址等信息都会消失，勾选perserve log后之前的请求都会被保留 2.2 filter过滤在url地址很多的时候，可以在filter中输入部分url地址，对所有的url地址起到一定的过滤效果，具体位置在上面第二幅图中的2的位置 2.3 观察特定种类的请求在上面第二幅图中的3的位置，有很多选项，默认是选择的all，即会观察到所有种类的请求 很多时候处于自己的目的可以选择all右边的其他选项，比如常见的选项： XHR:大部分情况表示ajax请求 JS:js请求 CSS:css请求 但是很多时候我们并不能保证我们需要的请求是什么类型，特别是我们不清楚一个请求是否为ajax请求的时候，直接选择all,从前往后观察即可，其中js，css，图片等不去观察即可 不要被浏览器中的一堆请求吓到了，这些请求中除了js，css，图片的请求外，其他的请求并没有多少个 3 寻找登录接口 回顾之前人人网的爬虫我们找到了一个登陆接口，那么这个接口从哪里找到的呢？ http://www.renren.com 3.1 寻找action对的url地址 可以发现，这个地址就是在登录的form表单中action对应的url地址，回顾前端的知识点，可以发现就是进行表单提交的地址，对应的，提交的数据，仅仅需要：用户名的input标签中，name的值作为键，用户名作为值，密码的input标签中，name的值作为键，密码作为值即可 思考：如果action对应的没有url地址的时候可以怎么做？ 3.2 通过抓包寻找登录的url地址 通过抓包可以发现，在这个url地址和请求体中均有参数，比如uniqueTimestamp和rkey以及加密之后的password 这个时候我们可以观察手机版的登录接口，是否也是一样的 可以发现在手机版中，依然有参数，但是参数的个数少一些，这个时候，我们可以使用手机版作为参考，下一节来学习如何分析js 小结 使用隐身窗口的主要目的是为了避免首次打开网站携带cookie的问题 chrome的network中，perserve log选项能够在页面发生跳转之后任然能够观察之前的请求 确定登录的地址有两种方法： 寻找from表单action的url地址 通过抓包获取","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.lovelves.cn/tags/爬虫/"},{"name":"python","slug":"python","permalink":"https://www.lovelves.cn/tags/python/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"爬虫学习之旅02-爬虫之验证码处理","slug":"爬虫之验证码处理","date":"2021-06-21T13:05:41.000Z","updated":"2021-06-21T13:08:31.629Z","comments":true,"path":"2021/06/21/爬虫之验证码处理/","link":"","permalink":"https://www.lovelves.cn/2021/06/21/爬虫之验证码处理/","excerpt":"","text":"验证码处理学习目标 了解 验证码的相关知识 掌握 图片识别引擎的使用 了解 常见的打码平台 掌握 通过打码平台处理验证码的方法 1.图片验证码1.1 什么是图片验证码 验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写，是一种区分用户是计算机还是人的公共全自动程序。 1.2 验证码的作用 防止恶意破解密码、刷票、论坛灌水、刷页。有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登录尝试，实际上使用验证码是现在很多网站通行的方式（比如招商银行的网上个人银行，百度社区），我们利用比较简易的方式实现了这个功能。虽然登录麻烦一点，但是对网友的密码安全来说这个功能还是很有必要，也很重要。 1.3 图片验证码在爬虫中的使用场景 注册 登录 频繁发送请求时，服务器弹出验证码进行验证 1.4 图片验证码的处理方案 手动输入(input) 这种方法仅限于登录一次就可持续使用的情况 图像识别引擎解析 使用光学识别引擎处理图片中的数据，目前常用于图片数据提取，较少用于验证码处理 打码平台 爬虫常用的验证码解决方案 2.图片识别引擎 OCR（Optical Character Recognition）是指使用扫描仪或数码相机对文本资料进行扫描成图像文件，然后对图像文件进行分析处理，自动识别获取文字信息及版面信息的软件。 2.1 什么是tesseract Tesseract，一款由HP实验室开发由Google维护的开源OCR引擎，特点是开源，免费，支持多语言，多平台。 项目地址：https://github.com/tesseract-ocr/tesseract 2.2 图片识别引擎环境的安装1 引擎的安装 mac环境下直接执行命令 brew install --with-training-tools tesseract windows环境下的安装可以通过exe安装包安装，下载地址可以从GitHub项目中的wiki找到。安装完成后记得将Tesseract 执行文件的目录加入到PATH中，方便后续调用。 linux环境下的安装 sudo apt-get install tesseract-ocr 2 Python库的安装 # PIL用于打开图片文件 pip/pip3 install pillow # pytesseract模块用于从图片中解析数据 pip/pip3 install pytesseract 2.3 图片识别引擎的使用 通过pytesseract模块的 image_to_string 方法就能将打开的图片文件中的数据提取成字符串数据，具体方法如下 from PIL import Image import pytesseract im = Image.open() result = pytesseract.image_to_string(im) print(result) 2.4 图片识别引擎的使用扩展 tesseract简单使用与训练 其他ocr平台 微软Azure 图像识别：https://azure.microsoft.com/zh-cn/services/cognitive-services/computer-vision/ 有道智云文字识别：http://aidemo.youdao.com/ocrdemo 阿里云图文识别：https://www.aliyun.com/product/cdi/ 腾讯OCR文字识别：https://cloud.tencent.com/product/ocr 3 打码平台1.为什么需要了解打码平台的使用现在很多网站都会使用验证码来进行反爬，所以为了能够更好的获取数据，需要了解如何使用打码平台爬虫中的验证码 2 常见的打码平台 云打码：http://www.yundama.com/ 能够解决通用的验证码识别 极验验证码智能识别辅助：http://jiyandoc.c2567.com/ 能够解决复杂验证码的识别 3 云打码的使用下面以云打码为例，了解打码平台如何使用 3.1 云打码官方接口下面代码是云打码平台提供，做了个简单修改，实现了两个方法： indetify:传入图片的响应二进制数即可 indetify_by_filepath:传入图片的路径即可识别 其中需要自己配置的地方是： username = &#39;whoarewe&#39; # 用户名 password = &#39;***&#39; # 密码 appid = 4283 # appid appkey = &#39;02074c64f0d0bb9efb2df455537b01c3&#39; # appkey codetype = 1004 # 验证码类型 云打码官方提供的api如下： #yundama.py import requests import json import time class YDMHttp: apiurl = &#39;http://api.yundama.com/api.php&#39; username = &#39;&#39; password = &#39;&#39; appid = &#39;&#39; appkey = &#39;&#39; def __init__(self, username, password, appid, appkey): self.username = username self.password = password self.appid = str(appid) self.appkey = appkey def request(self, fields, files=[]): response = self.post_url(self.apiurl, fields, files) response = json.loads(response) return response def balance(self): data = {&#39;method&#39;: &#39;balance&#39;, &#39;username&#39;: self.username, &#39;password&#39;: self.password, &#39;appid&#39;: self.appid, &#39;appkey&#39;: self.appkey} response = self.request(data) if (response): if (response[&#39;ret&#39;] and response[&#39;ret&#39;] &lt; 0): return response[&#39;ret&#39;] else: return response[&#39;balance&#39;] else: return -9001 def login(self): data = {&#39;method&#39;: &#39;login&#39;, &#39;username&#39;: self.username, &#39;password&#39;: self.password, &#39;appid&#39;: self.appid, &#39;appkey&#39;: self.appkey} response = self.request(data) if (response): if (response[&#39;ret&#39;] and response[&#39;ret&#39;] &lt; 0): return response[&#39;ret&#39;] else: return response[&#39;uid&#39;] else: return -9001 def upload(self, filename, codetype, timeout): data = {&#39;method&#39;: &#39;upload&#39;, &#39;username&#39;: self.username, &#39;password&#39;: self.password, &#39;appid&#39;: self.appid, &#39;appkey&#39;: self.appkey, &#39;codetype&#39;: str(codetype), &#39;timeout&#39;: str(timeout)} file = {&#39;file&#39;: filename} response = self.request(data, file) if (response): if (response[&#39;ret&#39;] and response[&#39;ret&#39;] &lt; 0): return response[&#39;ret&#39;] else: return response[&#39;cid&#39;] else: return -9001 def result(self, cid): data = {&#39;method&#39;: &#39;result&#39;, &#39;username&#39;: self.username, &#39;password&#39;: self.password, &#39;appid&#39;: self.appid, &#39;appkey&#39;: self.appkey, &#39;cid&#39;: str(cid)} response = self.request(data) return response and response[&#39;text&#39;] or &#39;&#39; def decode(self, filename, codetype, timeout): cid = self.upload(filename, codetype, timeout) if (cid &gt; 0): for i in range(0, timeout): result = self.result(cid) if (result != &#39;&#39;): return cid, result else: time.sleep(1) return -3003, &#39;&#39; else: return cid, &#39;&#39; def post_url(self, url, fields, files=[]): # for key in files: # files[key] = open(files[key], &#39;rb&#39;); res = requests.post(url, files=files, data=fields) return res.text username = &#39;whoarewe&#39; # 用户名 password = &#39;***&#39; # 密码 appid = 4283 # appid appkey = &#39;02074c64f0d0bb9efb2df455537b01c3&#39; # appkey filename = &#39;getimage.jpg&#39; # 文件位置 codetype = 1004 # 验证码类型 # 超时 timeout = 60 def indetify(response_content): if (username == &#39;username&#39;): print(&#39;请设置好相关参数再测试&#39;) else: # 初始化 yundama = YDMHttp(username, password, appid, appkey) # 登陆云打码 uid = yundama.login(); print(&#39;uid: %s&#39; % uid) # 查询余额 balance = yundama.balance(); print(&#39;balance: %s&#39; % balance) # 开始识别，图片路径，验证码类型ID，超时时间（秒），识别结果 cid, result = yundama.decode(response_content, codetype, timeout) print(&#39;cid: %s, result: %s&#39; % (cid, result)) return result def indetify_by_filepath(file_path): if (username == &#39;username&#39;): print(&#39;请设置好相关参数再测试&#39;) else: # 初始化 yundama = YDMHttp(username, password, appid, appkey) # 登陆云打码 uid = yundama.login(); print(&#39;uid: %s&#39; % uid) # 查询余额 balance = yundama.balance(); print(&#39;balance: %s&#39; % balance) # 开始识别，图片路径，验证码类型ID，超时时间（秒），识别结果 cid, result = yundama.decode(file_path, codetype, timeout) print(&#39;cid: %s, result: %s&#39; % (cid, result)) return result if __name__ == &#39;__main__&#39;: pass 4 常见的验证码的种类4.1 url地址不变，验证码不变这是验证码里面非常简单的一种类型，对应的只需要获取验证码的地址，然后请求，通过打码平台识别即可 4.2 url地址不变，验证码变化这种验证码的类型是更加常见的一种类型，对于这种验证码，大家需要思考： 在登录的过程中，假设我输入的验证码是对的，对方服务器是如何判断当前我输入的验证码是显示在我屏幕上的验证码，而不是其他的验证码呢？ 在获取网页的时候，请求验证码，以及提交验证码的时候，对方服务器肯定通过了某种手段验证我之前获取的验证码和最后提交的验证码是同一个验证码，那这个手段是什么手段呢？ 很明显，就是通过cookie来实现的，所以对应的，在请求页面，请求验证码，提交验证码的到时候需要保证cookie的一致性，对此可以使用requests.session来解决 小结 了解 验证码的相关知识 掌握 图片识别引擎的使用 了解 常见的打码平台 掌握 通过打码平台处理验证码的方法","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.lovelves.cn/tags/爬虫/"},{"name":"python","slug":"python","permalink":"https://www.lovelves.cn/tags/python/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"爬虫学习之旅01-防爬和常用爬虫手段","slug":"防爬和常用爬虫手段","date":"2021-06-21T12:58:31.000Z","updated":"2021-06-21T13:08:34.109Z","comments":true,"path":"2021/06/21/防爬和常用爬虫手段/","link":"","permalink":"https://www.lovelves.cn/2021/06/21/防爬和常用爬虫手段/","excerpt":"","text":"常见的反爬手段和解决思路学习目标 了解 服务器反爬的原因 了解 服务器常反什么样的爬虫 了解 反爬虫领域常见的一些概念 了解 反爬的三个方向 了解 常见基于身份识别进行反爬 了解 常见基于爬虫行为进行反爬 了解 常见基于数据加密进行反爬 1 服务器反爬的原因 爬虫占总PV(PV是指页面的访问次数，每打开或刷新一次页面，就算做一个pv)比例较高，这样浪费钱（尤其是三月份爬虫）。 三月份爬虫是个什么概念呢？每年的三月份我们会迎接一次爬虫高峰期，有大量的硕士在写论文的时候会选择爬取一些往网站，并进行舆情分析。因为五月份交论文，所以嘛，大家都是读过书的，你们懂的，前期各种DotA，LOL，到了三月份了，来不及了，赶紧抓数据，四月份分析一下，五月份交论文，就是这么个节奏。 公司可免费查询的资源被批量抓走，丧失竞争力，这样少赚钱。 数据可以在非登录状态下直接被查询。如果强制登陆，那么可以通过封杀账号的方式让对方付出代价，这也是很多网站的做法。但是不强制对方登录。那么如果没有反爬虫，对方就可以批量复制的信息，公司竞争力就会大大减少。竞争对手可以抓到数据，时间长了用户就会知道，只需要去竞争对手那里就可以了，没必要来我们网站，这对我们是不利的。 状告爬虫成功的几率小 爬虫在国内还是个擦边球，就是有可能可以起诉成功，也可能完全无效。所以还是需要用技术手段来做最后的保障。 2 服务器常反什么样的爬虫 十分低级的应届毕业生 应届毕业生的爬虫通常简单粗暴，根本不管服务器压力，加上人数不可预测，很容易把站点弄挂。 十分低级的创业小公司 现在的创业公司越来越多，也不知道是被谁忽悠的然后大家创业了发现不知道干什么好，觉得大数据比较热，就开始做大数据。分析程序全写差不多了，发现自己手头没有数据。怎么办？写爬虫爬啊。于是就有了不计其数的小爬虫，出于公司生死存亡的考虑，不断爬取数据。 不小心写错了没人去停止的失控小爬虫 有些网站已经做了相应的反爬，但是爬虫依然孜孜不倦地爬取。什么意思呢？就是说，他们根本爬不到任何数据，除了httpcode是200以外，一切都是不对的，可是爬虫依然不停止这个很可能就是一些托管在某些服务器上的小爬虫，已经无人认领了，依然在辛勤地工作着。 成型的商业对手 这个是最大的对手，他们有技术，有钱，要什么有什么，如果和你死磕，你就只能硬着头皮和他死磕。 抽风的搜索引擎 大家不要以为搜索引擎都是好人，他们也有抽风的时候，而且一抽风就会导致服务器性能下降，请求量跟网络攻击没什么区别。 3 反爬虫领域常见的一些概念因为反爬虫暂时是个较新的领域，因此有些定义要自己下： 爬虫：使用任何技术手段，批量获取网站信息的一种方式。关键在于批量。 反爬虫：使用任何技术手段，阻止别人批量获取自己网站信息的一种方式。关键也在于批量。 误伤：在反爬虫的过程中，错误的将普通用户识别为爬虫。误伤率高的反爬虫策略，效果再好也不能用。 拦截：成功地阻止爬虫访问。这里会有拦截率的概念。通常来说，拦截率越高的反爬虫策略，误伤的可能性就越高。因此需要做个权衡。 资源：机器成本与人力成本的总和。 这里要切记，人力成本也是资源，而且比机器更重要。因为，根据摩尔定律，机器越来越便宜。而根据IT行业的发展趋势，程序员工资越来越贵。因此，通常服务器反爬就是让爬虫工程师加班才是王道，机器成本并不是特别值钱。 4 反爬的三个方向 基于身份识别进行反爬 基于爬虫行为进行反爬 基于数据加密进行反爬 5 常见基于身份识别进行反爬1 通过headers字段来反爬 headers中有很多字段，这些字段都有可能会被对方服务器拿过来进行判断是否为爬虫 1.1 通过headers中的User-Agent字段来反爬 反爬原理：爬虫默认情况下没有User-Agent，而是使用模块默认设置 解决方法：请求之前添加User-Agent即可；更好的方式是使用User-Agent池来解决（收集一堆User-Agent的方式，或者是随机生成User-Agent） 1.2 通过referer字段或者是其他字段来反爬 反爬原理：爬虫默认情况下不会带上referer字段，服务器端通过判断请求发起的源头，以此判断请求是否合法 解决方法：添加referer字段 1.3 通过cookie来反爬 反爬原因：通过检查cookies来查看发起请求的用户是否具备相应权限，以此来进行反爬 解决方案：进行模拟登陆，成功获取cookies之后在进行数据爬取 2 通过请求参数来反爬 请求参数的获取方法有很多，向服务器发送请求，很多时候需要携带请求参数，通常服务器端可以通过检查请求参数是否正确来判断是否为爬虫 2.1 通过从html静态文件中获取请求数据(github登录数据) 反爬原因：通过增加获取请求参数的难度进行反爬 解决方案：仔细分析抓包得到的每一个包，搞清楚请求之间的联系 2.2 通过发送请求获取请求数据 反爬原因：通过增加获取请求参数的难度进行反爬 解决方案：仔细分析抓包得到的每一个包，搞清楚请求之间的联系，搞清楚请求参数的来源 2.3 通过js生成请求参数 反爬原理：js生成了请求参数 解决方法：分析js，观察加密的实现过程，通过js2py获取js的执行结果，或者使用selenium来实现 2.4 通过验证码来反爬 反爬原理：对方服务器通过弹出验证码强制验证用户浏览行为 解决方法：打码平台或者是机器学习的方法识别验证码，其中打码平台廉价易用，更值得推荐 6 常见基于爬虫行为进行反爬1 基于请求频率或总请求数量 爬虫的行为与普通用户有着明显的区别，爬虫的请求频率与请求次数要远高于普通用户 1.1 通过请求ip/账号单位时间内总请求数量进行反爬 反爬原理：正常浏览器请求网站，速度不会太快，同一个ip/账号大量请求了对方服务器，有更大的可能性会被识别为爬虫 解决方法：对应的通过购买高质量的ip的方式能够解决问题/购买个多账号 1.2 通过同一ip/账号请求之间的间隔进行反爬 反爬原理：正常人操作浏览器浏览网站，请求之间的时间间隔是随机的，而爬虫前后两个请求之间时间间隔通常比较固定同时时间间隔较短，因此可以用来做反爬 解决方法：请求之间进行随机等待，模拟真实用户操作，在添加时间间隔后，为了能够高速获取数据，尽量使用代理池，如果是账号，则将账号请求之间设置随机休眠 1.3 通过对请求ip/账号每天请求次数设置阈值进行反爬 反爬原理：正常的浏览行为，其一天的请求次数是有限的，通常超过某一个值，服务器就会拒绝响应 解决方法：对应的通过购买高质量的ip的方法/多账号，同时设置请求间随机休眠 2 根据爬取行为进行反爬，通常在爬取步骤上做分析2.1 通过js实现跳转来反爬 反爬原理：js实现页面跳转，无法在源码中获取下一页url 解决方法: 多次抓包获取条状url，分析规律 2.2 通过蜜罐(陷阱)获取爬虫ip(或者代理ip)，进行反爬 反爬原理：在爬虫获取链接进行请求的过程中，爬虫会根据正则，xpath，css等方式进行后续链接的提取，此时服务器端可以设置一个陷阱url，会被提取规则获取，但是正常用户无法获取，这样就能有效的区分爬虫和正常用户 解决方法: 完成爬虫的编写之后，使用代理批量爬取测试/仔细分析响应内容结构，找出页面中存在的陷阱 2.3 通过假数据反爬 反爬原理：向返回的响应中添加假数据污染数据库，通常家属剧不会被正常用户看到 解决方法: 长期运行，核对数据库中数据同实际页面中数据对应情况，如果存在问题/仔细分析响应内容 2.4 阻塞任务队列 反爬原理：通过生成大量垃圾url，从而阻塞任务队列，降低爬虫的实际工作效率 解决方法: 观察运行过程中请求响应状态/仔细分析源码获取垃圾url生成规则，对URL进行过滤 2.5 阻塞网络IO 反爬原理：发送请求获取响应的过程实际上就是下载的过程，在任务队列中混入一个大文件的url，当爬虫在进行该请求时将会占用网络io，如果是有多线程则会占用线程 解决方法: 观察爬虫运行状态/多线程对请求线程计时/发送请求钱 2.6 运维平台综合审计 反爬原理：通过运维平台进行综合管理，通常采用复合型反爬虫策略，多种手段同时使用 解决方法: 仔细观察分析，长期运行测试目标网站，检查数据采集速度，多方面处理 7 常见基于数据加密进行反爬1 对响应中含有的数据进行特殊化处理 通常的特殊化处理主要指的就是css数据偏移/自定义字体/数据加密/数据图片/特殊编码格式等 1.1 通过自定义字体来反爬下图来自猫眼电影电脑版 反爬思路: 使用自有字体文件 解决思路：切换到手机版/解析字体文件进行翻译 1.2 通过css来反爬 下图来自猫眼去哪儿电脑版 反爬思路：源码数据不为真正数据，需要通过css位移才能产生真正数据 解决思路：计算css的偏移 1.3 通过js动态生成数据进行反爬 反爬原理：通过js动态生成 解决思路：解析关键js，获得数据生成流程，模拟生成数据 1.4 通过数据图片化反爬 58同城短租](https://baise.58.com/duanzu/38018718834984x.shtml) 解决思路：通过使用图片解析引擎从图片中解析数据 1.5 通过编码格式进行反爬 反爬原理: 不适用默认编码格式，在获取响应之后通常爬虫使用utf-8格式进行解码，此时解码结果将会是乱码或者报错 解决思路：根据源码进行多格式解码，或者真正的解码格式 小结 掌握 常见的反爬手段、原理以及应对思路","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.lovelves.cn/tags/爬虫/"},{"name":"python","slug":"python","permalink":"https://www.lovelves.cn/tags/python/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"mybatis-day02笔记","slug":"mybatis-day02笔记","date":"2021-06-17T09:41:20.000Z","updated":"2021-06-18T11:12:08.000Z","comments":true,"path":"2021/06/17/mybatis-day02笔记/","link":"","permalink":"https://www.lovelves.cn/2021/06/17/mybatis-day02笔记/","excerpt":"","text":"1.Mybatis的Dao层实现1.1 传统开发方式1.1.1编写UserDao接口public interface UserDao { List&lt;User&gt; findAll() throws IOException; } 1.1.2.编写UserDaoImpl实现public class UserDaoImpl implements UserDao { public List&lt;User&gt; findAll() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;); sqlSession.close(); return userList; } } 1.1.3 测试传统方式@Test public void testTraditionDao() throws IOException { UserDao userDao = new UserDaoImpl(); List&lt;User&gt; all = userDao.findAll(); System.out.println(all); } 1.2 代理开发方式1.2.1 代理开发方式介绍采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper 接口开发需要遵循以下规范： 1) Mapper.xml文件中的namespace与mapper接口的全限定名相同 2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 1.2.2 编写UserMapper接口 1.2.3测试代理方式@Test public void testProxyDao() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); //获得MyBatis框架生成的UserMapper接口的实现类 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.findById(1); System.out.println(user); sqlSession.close(); } 1.3 知识小结MyBatis的Dao层实现的两种方式： 手动对Dao进行实现：传统开发方式 代理方式对Dao进行实现： **UserMapper userMapper = sqlSession.getMapper(UserMapper.class);** 2.MyBatis映射文件深入2.1 动态sql语句2.1.1动态sql语句概述Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。 参考的官方文档，描述如下： 2.1.2动态 SQL 之&lt;if&gt;我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 &lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from User &lt;where&gt; &lt;if test=&quot;id!=0&quot;&gt; and id=#{id} &lt;/if&gt; &lt;if test=&quot;username!=null&quot;&gt; and username=#{username} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 当查询条件id和username都存在时，控制台打印的sql语句如下： … … … //获得MyBatis框架生成的UserMapper接口的实现类 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User condition = new User(); condition.setId(1); condition.setUsername(&quot;lucy&quot;); User user = userMapper.findByCondition(condition); … … … 当查询条件只有id存在时，控制台打印的sql语句如下： … … … //获得MyBatis框架生成的UserMapper接口的实现类 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User condition = new User(); condition.setId(1); User user = userMapper.findByCondition(condition); … … … 2.1.3 动态 SQL 之&lt;foreach&gt;循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。 &lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; select * from User &lt;where&gt; &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #{id} &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; 测试代码片段如下： … … … //获得MyBatis框架生成的UserMapper接口的实现类 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int[] ids = new int[]{2,5}; List&lt;User&gt; userList = userMapper.findByIds(ids); System.out.println(userList); … … … foreach标签的属性含义如下： 标签用于遍历集合，它的属性： •collection：代表要遍历的集合元素，注意编写时不要写#{} •open：代表语句的开始部分 •close：代表结束部分 •item：代表遍历集合的每个元素，生成的变量名 •sperator：代表分隔符 2.2 SQL片段抽取Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的 &lt;!--抽取sql片段简化编写--&gt; &lt;sql id=&quot;selectUser&quot; select * from User&lt;/sql&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; where id=#{id} &lt;/select&gt; &lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #{id} &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; 2.3 知识小结MyBatis映射文件配置： ：查询 ：插入 ：修改 ：删除 ：where条件 ：if判断 ：循环 ：sql片段抽取 3. MyBatis核心配置文件深入3.1typeHandlers标签无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器（截取部分）。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。 开发步骤： ①定义转换类继承类BaseTypeHandler ②覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时 mysql的字符串类型转换成 java的Type类型的方法 ③在MyBatis核心配置文件中进行注册 测试转换是否正确 public class MyDateTypeHandler extends BaseTypeHandler&lt;Date&gt; { public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType type) { preparedStatement.setString(i,date.getTime()+&quot;&quot;); } public Date getNullableResult(ResultSet resultSet, String s) throws SQLException { return new Date(resultSet.getLong(s)); } public Date getNullableResult(ResultSet resultSet, int i) throws SQLException { return new Date(resultSet.getLong(i)); } public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException { return callableStatement.getDate(i); } } &lt;!--注册类型自定义转换器--&gt; &lt;typeHandlers&gt; &lt;typeHandler handler=&quot;com.itheima.typeHandlers.MyDateTypeHandler&quot;&gt;&lt;/typeHandler&gt; &lt;/typeHandlers&gt; 测试添加操作： user.setBirthday(new Date()); userMapper.add2(user); 数据库数据： 测试查询操作： 3.2 plugins标签MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据 开发步骤： ①导入通用PageHelper的坐标 ②在mybatis核心配置文件中配置PageHelper插件 ③测试分页数据获取 ①导入通用PageHelper坐标&lt;!-- 分页助手 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;3.7.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; ②在mybatis核心配置文件中配置PageHelper插件&lt;!-- 注意：分页助手的插件 配置在通用馆mapper之前 --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;!-- 指定方言 --&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt; ③测试分页代码实现@Test public void testPageHelper(){ //设置分页参数 PageHelper.startPage(1,2); List&lt;User&gt; select = userMapper2.select(null); for(User user : select){ System.out.println(user); } } 获得分页相关的其他参数 //其他分页的数据 PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(select); System.out.println(&quot;总条数：&quot;+pageInfo.getTotal()); System.out.println(&quot;总页数：&quot;+pageInfo.getPages()); System.out.println(&quot;当前页：&quot;+pageInfo.getPageNum()); System.out.println(&quot;每页显示长度：&quot;+pageInfo.getPageSize()); System.out.println(&quot;是否第一页：&quot;+pageInfo.isIsFirstPage()); System.out.println(&quot;是否最后一页：&quot;+pageInfo.isIsLastPage()); 3.3 知识小结MyBatis核心配置文件常用标签： 1、properties标签：该标签可以加载外部的properties文件 2、typeAliases标签：设置类型别名 3、environments标签：数据源环境配置标签 4、typeHandlers标签：配置自定义类型处理器 5、plugins标签：配置MyBatis的插件","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.lovelves.cn/tags/springboot/"},{"name":"mybatis","slug":"mybatis","permalink":"https://www.lovelves.cn/tags/mybatis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"mybatis-day01笔记","slug":"mybatis-day01笔记","date":"2021-06-17T06:15:50.000Z","updated":"2021-06-17T13:14:49.977Z","comments":true,"path":"2021/06/17/mybatis-day01笔记/","link":"","permalink":"https://www.lovelves.cn/2021/06/17/mybatis-day01笔记/","excerpt":"","text":"1.Mybatis简介1.1原始jdbc操作（查询数据） 1.2原始jdbc操作（插入数据） 1.3 原始jdbc操作的分析原始jdbc开发存在的问题如下： ①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能 ②sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。 ③查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置 应对上述问题给出的解决方案： ①使用数据库连接池初始化连接资源 ②将sql语句抽取到xml配置文件中 ③使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射 1.4 什么是Mybatismybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。 最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。 2.Mybatis的快速入门2.1 MyBatis开发步骤MyBatis官网地址：http://www.mybatis.org/mybatis-3/ MyBatis开发步骤： ①添加MyBatis的坐标 ②创建user数据表 ③编写User实体类 ④编写映射文件UserMapper.xml ⑤编写核心文件SqlMapConfig.xml ⑥编写测试类 2.2 环境搭建1)导入MyBatis的坐标和其他相关坐标 &lt;!--mybatis坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--单元测试坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--日志坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; 2) 创建user数据表 3) 编写User实体 public class User { private int id; private String username; private String password; //省略get个set方法 } 4)编写UserMapper映射文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from User &lt;/select&gt; &lt;/mapper&gt; 5) 编写MyBatis核心文件 &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN“ &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 2.3 编写测试代码//加载核心配置文件 InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //获得sqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); //获得sqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //执行sql语句 List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;); //打印结果 System.out.println(userList); //释放资源 sqlSession.close(); 2.4 知识小结MyBatis开发步骤： ①添加MyBatis的坐标 ②创建user数据表 ③编写User实体类 ④编写映射文件UserMapper.xml ⑤编写核心文件SqlMapConfig.xml ⑥编写测试类 3. MyBatis的映射文件概述 4. MyBatis的增删改查操作4.1 MyBatis的插入数据操作1)编写UserMapper映射文件 &lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; insert into user values(#{id},#{username},#{password}) &lt;/insert&gt; &lt;/mapper&gt; 2)编写插入实体User的代码 InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); int insert = sqlSession.insert(&quot;userMapper.add&quot;, user); System.out.println(insert); //提交事务 sqlSession.commit(); sqlSession.close(); 3)插入操作注意问题 • 插入语句使用insert标签 • 在映射文件中使用parameterType属性指定要插入的数据类型 •Sql语句中使用#{实体属性名}方式引用实体中的属性值 •插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象); •插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit() 4.2 MyBatis的修改数据操作1)编写UserMapper映射文件 &lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; update user set username=#{username},password=#{password} where id=#{id} &lt;/update&gt; &lt;/mapper&gt; 2)编写修改实体User的代码 InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); int update = sqlSession.update(&quot;userMapper.update&quot;, user); System.out.println(update); sqlSession.commit(); sqlSession.close(); 3)修改操作注意问题 • 修改语句使用update标签 • 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象); 4.3 MyBatis的删除数据操作1)编写UserMapper映射文件 &lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id=#{id} &lt;/delete&gt; &lt;/mapper&gt; 2)编写删除数据的代码 InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); int delete = sqlSession.delete(&quot;userMapper.delete&quot;,3); System.out.println(delete); sqlSession.commit(); sqlSession.close(); 3)删除操作注意问题 • 删除语句使用delete标签 •Sql语句中使用#{任意字符串}方式引用传递的单个参数 •删除操作使用的API是sqlSession.delete(“命名空间.id”,Object); 4.4 知识小结增删改查映射配置与API： 查询数据： List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;); &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from User &lt;/select&gt; 添加数据： sqlSession.insert(&quot;userMapper.add&quot;, user); &lt;insert id=&quot;add&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; insert into user values(#{id},#{username},#{password}) &lt;/insert&gt; 修改数据： sqlSession.update(&quot;userMapper.update&quot;, user); &lt;update id=&quot;update&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; update user set username=#{username},password=#{password} where id=#{id} &lt;/update&gt; 删除数据：sqlSession.delete(&quot;userMapper.delete&quot;,3); &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id=#{id} &lt;/delete&gt; 5. MyBatis核心配置文件概述5.1 MyBatis核心配置文件层级关系 5.2 MyBatis常用配置解析1)environments标签 数据库环境的配置，支持多环境配置 其中，事务管理器（transactionManager）类型有两种： •JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 •MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： •UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 •POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 •JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 2)mapper标签 该标签的作用是加载映射的，加载方式有如下几种： •使用相对于类路径的资源引用，例如： •使用完全限定资源定位符（URL），例如： •使用映射器接口实现类的完全限定类名，例如： •将包内的映射器接口实现全部注册为映射器，例如： 3)Properties标签 实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件 4)typeAliases标签 类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下 配置typeAliases，为com.itheima.domain.User定义别名为user 上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名 5.3 知识小结核心配置文件常用配置： properties标签：该标签可以加载外部的properties文件 &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt; typeAliases标签：设置类型别名 &lt;typeAlias type=&quot;com.itheima.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt; mappers标签：加载映射配置 &lt;mapper resource=&quot;com/itheima/mapper/UserMapping.xml&quot;&gt;&lt;/mapper&gt; environments标签：数据源环境配置标签 6.MyBatis相应API6.1 SqlSession工厂构建器SqlSessionFactoryBuilder常用API：SqlSessionFactory build(InputStream inputStream) 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象 String resource = &quot;org/mybatis/builder/mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream); 其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。 6.2 SqlSession工厂对象SqlSessionFactorySqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个： 6.3 SqlSession会话对象SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。 执行语句的方法主要有： &lt;T&gt; T selectOne(String statement, Object parameter) &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) int insert(String statement, Object parameter) int update(String statement, Object parameter) int delete(String statement, Object parameter) 操作事务的方法主要有： void commit() void rollback() ####","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.lovelves.cn/tags/springboot/"},{"name":"mybatis","slug":"mybatis","permalink":"https://www.lovelves.cn/tags/mybatis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"前端笔记es6语法学习","slug":"前端笔记es6语法学习","date":"2021-06-16T12:52:32.000Z","updated":"2021-06-16T12:54:54.620Z","comments":true,"path":"2021/06/16/前端笔记es6语法学习/","link":"","permalink":"https://www.lovelves.cn/2021/06/16/前端笔记es6语法学习/","excerpt":"","text":"es6 学习1，var const let 的区别 变量提升console.log(i); var i=100; 以上代码 在正规的语法中 理应报错 因为变量i未声明过 然而并没有报错 打印出undefined这是由于var关键字的作用 var声明的变量 无论在程序的哪一行 都会把声明置顶 程序这样翻译var i; console.log(i); i=100 然而以上代码中 var 关键字 改为let 就会杜绝这种情况的出现 在哪行声明 就在哪行 并不会置顶 var、let声明的就是变量，变量一旦初始化之后，还可以重新赋值 Const 声明的是常量 const声明后必须立即初始化 const 声明的常量可以修改 但不能重新赋值 重复声明 var 允许重复声明，let、const 不允许 var 没有块级作用域 let/const 有块级作用域 用var定义的变量 在windows对象的属性和方法（全局作用域） const let 则没有 2，模板字符串 模板字符串与一般字符串一样 唯一区别 模板字符串可以直接注入变量 const person = { username: &#39;Alex&#39;, age: 18, sex: &#39;male&#39; }; const info = &#39;我的名字是：&#39; + person.username + &#39;, 性别：&#39; + person.sex + &#39;, 今年&#39; + person.age + &#39;岁了&#39;; console.log(info); 普通字符串只能 通过加号和变量拼接 但是模板字符串可以很方便的注入变量 const info = `我的名字是：${person.username}, 性别：${person.sex}, 今年${person.age}岁了`; console.log(info); 模板字符串的注意事项输出多行字符串 一般字符串 const info = &#39;第1行\\n第2行&#39;; console.log(info); 模板字符串 const info = `第1行\\n第2行`; const info = `第1行 第2行`; console.log(info); 模板字符串中，所有的空格、换行或缩进都会被保留在输出之中模板字符串的注入(方法 表达式 对象) ${} const username = &#39;alex&#39;; const person = { age: 18, sex: &#39;male&#39; }; const getSex = function (sex) { return sex === &#39;male&#39; ? &#39;男&#39; : &#39;女&#39;; }; const info = `${username}, ${person.age + 2}, ${getSex(person.sex)}`; console.log(info); 只要最终可以得出一个值的就可以通过 ${} 注入到模板字符串中 3，箭头函数 .认识箭头函数`javascript const add = (x, y) =&gt; {return x + y; }; console.log(add(1, 1)); 箭头函数的结构 const/let 函数名 = 参数 =&gt; 函数体 如何将一般函数改写成箭头函数 声明形式 ```javascript function add() {} 声明形式-&gt;函数表达式形式 const add = function () {}; 函数表达式形式-&gt;箭头函数 const add = () =&gt; {}; 1.单个参数(单个参数可以省略圆括号) const add = x =&gt; { return x + 1; }; console.log(add(1)); 无参数或多个参数不能省略圆括号 const add = () =&gt; { return 1 + 1; }; const add = (x, y) =&gt; { return x + y; }; console.log(add(1, 1)); 3.单行函数体单行函数体可以同时省略 {} 和 return const add = (x, y) =&gt; { return x + y; }; const add = (x, y) =&gt; x + y; console.log(add(1, 1)); 4.多行函数体不能再化简了 const add = (x, y) =&gt; { const sum = x + y; return sum; }; 5.单行对象(如果箭头函数返回单行对象，可以在 {} 外面加上 ()，让浏览器不再认为那是函数体的花括号) const add = (x, y) =&gt; { return { value: x + y }; }; const add = (x, y) =&gt; ({ value: x + y }); 4 非箭头函数中的 this 指向1.全局作用域中的 this 指向 console.log(this); // window 2.一般函数（非箭头函数）中的 this 指向 &#39;use strict&#39;; function add() { console.log(this); } add(); 3.严格模式就指向 undefined add(); // undefined-&gt;window（非严格模式下） const calc = { add: add }; calc.add(); // 指向 calc const adder = calc.add; adder(); // undefined-&gt;window（非严格模式下） document.onclick = function () { console.log(this); }; document.onclick(); function Person(username) { this.username = username; console.log(this); } const p = new Person(&#39;Alex&#39;); 只有在函数调用的时候 this 指向才确定，不调用的时候，不知道指向谁this 指向和函数在哪儿调用没关系，只和谁在调用有关没有具体调用对象的话，this 指向 undefined，在非严格模式下，转向 window 箭头函数没有this指向 解构赋值1.模式（结构）匹配 {}={} []=[] 属性名相同的完成赋值 const { age, username } = { username: &#39;Alex&#39;, age: 18 }; 取别名 const { age: age, username: uname } = { username: &#39;Alex&#39;, age: 18 }; 默认值的生效条件 对象的属性值严格等于 undefined 时，对应的默认值才会生效 const { username = &#39;ZhangSan&#39;, age = 0 } = { username: &#39;alex&#39; }; console.log(username, age); 默认值表达式 如果默认值是表达式，默认值表达式是惰性求值的 如果将一个已经声明的变量用于对象的解构赋值，整个赋值需在圆括号中进行 let x = 2; ({ x } = { x: 1 }); [x] = [1]; console.log(x); 应用 1.函数参数的解构赋值 const logPersonInfo = ({ age = 0, username = &#39;ZhangSan&#39; }) =&gt; console.log(username, age); 剩余参数剩余参数永远是个数组 即使没有值也是空数组 const a = (...args)=&gt;{ console.log(args); } a(1,3,5,6) 注意 箭头函数的参数部分即使只有一个剩余函数，也不能省略（） 使用剩余函数代替函数的arguments const a = function(){ console.log(arguments); } a(1,2); 由于arguments 在箭头函数中不可用 用剩余函数代替 ​ 剩余函数必须是参数的最后位置 否则会报错 剩余参数和结构赋值的结合使用 let [f,b,...c]=[1,2,3,4,5]; console.log(c); //[3,4,5] let {h,y,...p}={x:2,y:3,h:8,o:9} console.log(p);//{x: 2, o: 9} 剩余参数的应用 const a = (...args)=&gt;{ let sum=0; for(let i =0;i&lt;args.length;i++){ sum=args[i]+sum; } return sum; } let sum=a(1,7,8); console.log(sum); 认识展开运算符就是把数组形式展开 如 【1，2，3】—&gt;. (1,2,3) 例子 console.log(Math.min(...[3,1,2])) 跟剩余函数的根本区别 剩余函数 是 3，1，3 ——&gt; [3,1,3] 展开运算符是 [3,1,3] ———&gt; 3,1,3 例子 //剩余参数 const add = (...args)=&gt;{ //展开运算符 console.log(...args); //1,2,3 console.log([...[1,2,3],4,5,6])//1,2,3,4,5,6 } add([1,2,3]); 数组运算符的应用 复制数组 例子 const a = [1,2,3]; const b = a; a[0]=3; console.log(b) 上面代码 只是把a 数组的引用赋值给b. 说白了 就是给a 取了一个别名 b 正确做法 用数组运算符 const c = [...a]; a[0]=2; console.log(c); 合并数组 const a = [1,2]; const b = [3,4,5]; const c = [5,6]; const d = [...a,...b,...c];// 把abc合并一个数组 将字符串转化为数组 console.log([...&#39;lovelves&#39;]) 将函数的arguments、Nodelist 转化为数组 const b = function(){ console.log([...arguments]) } 展开对象 对象必须在{}中展开 展开后就是把属性罗列出来 用逗号分隔放在{}中 构成新的对象 const apple ={ color:&#39;红色&#39;, shape:&#39;球形&#39; } console.log({...apple}===apple)//false 合并对象 const apple ={ color:&#39;红色&#39;, shape:&#39;球型&#39; }; const pen ={ color:&#39;黑色&#39;, shape:&#39;圆形&#39; } {...apple,...pen}//合并成一个对象 新对象拥有全部的属性 相同属性 后者覆盖 注意事项 空对象的展开（如果展开一个空对象 则没有任何效果） 非对象展开（如果展开的不是对象 则会自动转换成对象 并把属性罗列出来） console.log(...1); console.log(...undefined); console.log(...null); //上面得出结果为空 {} 如果展开的运算符后面是字符串 它会自动转成一个类数组对象 console.log({...&#39;lovelves&#39;})//{0:l,1:o .....} 不会展开对象中的对象属性 const pen ={ color:&#39;黑色&#39;, shape:&#39;圆形&#39; hide: { color:&#39;black&#39;, shape: true } } {...pen}// {color:&#39;黑色&#39;，shape：&#39;圆形&#39;，hide{...}} 对象展开运算符的应用 1.复制对象 2.用户参数和默认参数 const logUser = userParam=&gt;{ const defaultParam={ username:&#39;zhangsan&#39;, age:0, sex:&#39;male&#39; }; const param ={...defaultParam,...userParam} console.log(param.username) }; logUser(); SetSet 是一系列无序、没有重复值的数据集合 const s = new Set(); s.add(1); s.add(2); s.add(1);//这里既时加入了 也没作用 Set中不允许有重复成员 console.log(s); Set 没有下标去标示每一个值 所以Set是无序的，也不能像数组那样用过下标访问成员变量 方法 1.add(在set中添加元素) const s = new Set(); s.add(1).add(3); 2.has(判断是否存在) s.has(1); 3.delete（删除某个元素 即使不存在 也不会报错） s.delete(1); 4.clear (清除set中的所有元素) s.clear(); 5.forEach(按照成员添加进集合的顺序遍历) s.forEach(function(value,key,set){ console.log(value,key,set===s);//在set中 value和key一样 console.log(this);//this指向document 因为函数中的第二个参数写了doucument },document); console.log(s); 属性 1.size（显示成员的个数） s.size 构造函数 通过构造函数初始化成员传入数组、字符串、arguments、 Nodelist、 set 等 const s = new Set([1,2,1]); console.log(s); const b = new Set(s);//复制了一份s console.log(b===s); //false 注意事项 如何判断重复的方式 set中对重复值的判断基本标准遵循严格相等=== 但是对于NaN 在set中 NaN===NaN 而实际NaN不等于NaN const s = new Set([NaN,1,NaN]) console.log(s) //只有2个数据 1 NaN console.log(NaN===NaN)//false 什么时候使用set 1.数组或字符串去重时 2.不需要下标访问 只需要遍历时 3.为了使用set中的方法时 Mapmap 和对象都是键值对的集合 const m = neew Map(); m.set(&#39;name&#39;,&#39;lovelves&#39;);//键是name 值是lovelves console.log(m); map和对象的区别 在对象中 键都是字符串 const obj = { name;&#39;alex&#39;//name 其实是个字符串 } 而在map中 键的类型可以是任意类型 const m = new Map(); m.set({},&#39;object&#39;); map的方法和属性（跟set使用一样 就不举例了） 1.set(添加成员 如果键中已存在 后添加会覆盖已有的) 2.get（获取成员 如果获取不存在的会返回undefined） 3.has（判断是否存在） 4.delete（删除成员） 5.clear（清除所有成员） 6.foreach（遍历） 属性 size（获取多少成员） 构造函数 可以传入数组 这里的数组必须是二维数组 set 、map 中 使用方法跟set一样 注意事项 判断键名是否相同的方式（跟set中一样） 什么时候使用map 如果需要key-&gt;value的结构 或者需要字符串以外的值做键 使用map 使用map中的方法 如遍历 map开发中的应用 把dom元素放入到map中应用 &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;script&gt; const [p1,p2,p3,p4]=document.querySelectorAll(&#39;p&#39;); const b = new Map( [[p1,{color:&quot;red&quot;,backgroundColor:&quot;red&quot;}], [p2,{color:&quot;blue&quot;,backgroundColor:&quot;blue&quot;}], [p3,{color:&quot;black&quot;,backgroundColor:&quot;black&quot;}], [p4,{color:&quot;yellow&quot;,backgroundColor:&quot;yellow&quot;}] ] ); console.log(b); b.forEach(function(val,ele,map){ for (const v in val) { ele.style[v]=val[v]; } },document) &lt;/script&gt; IteratorIterator 遍历器 迭代器 什么是iterator Symbol.iterator(可遍历对象的生成方法)—&gt;it（可遍历对象）—&gt;it.next()—&gt;it.next()…(直到done为true) const it = [1,2][Symbol.iterator](); console.log(it.next());//{value:1,done:false} console.log(it.next());//{value:2,done:false} console.log(it.next());//{value:underfined,done:true} For …of 的用法 const arr = [1,2,3]; for(const item of arr){ console.log(item); } //循环遍历那些done为false对应的值 与break continue 一起使用 const arr = [1,2,3]; for(const item of arr){ if(item===2){ break; //continue; } console.log(item); } 获取数组的索引和值 const arr = [1,2,3]; for(const [index,value] of arr.entries()){ console.log(index,value); } 获取数组中索引 const arr = [1,2,3]; for(const [index,value] of arr.keys()){ console.log(index,value); } 什么是可遍历的 只要有Symbol.iterator方法 并且这个方法可以生成可遍历对象 就是可遍历的 只要可遍历 就可以使用 for of 方法遍历 原生可遍历的有哪些 1.数组 2.字符串 3.set 4.map 5.arguments 6.nodelist 非原生可遍历的有哪些 一般对象拥有可遍历 就是自己写 const obj = { age:18, name:&#39;lovelves&#39;, address:&#39;beijing&#39; } obj[Symbol.iterator]=()=&gt;{ let index=0; return { next: function(){ index++; if (index===1){ return { value: obj.age, done: false } }else if(index===2){ return{ value: obj.name, done: false } }else if(index===3){ return{ value: obj.address, done: false } }else{ return{ value: undefined, done: true } } } } } for (const i of obj) { console.log(i); } 使用了lterator的场合 1.数组展开运算符 2.数组的解构赋值 3。set和map中的构造函数 字符串的新方法includes方法 判断是否包含某个字符串 第一个参数是判断包含的字符串 第二个参数是从哪个位置开始判断 应用 拼接url地址 let url = &quot;https://wwww.lovelves.com/course/list&quot;; const addUrlParam = (url,name,value)=&gt;{ url+= url.includes(&quot;?&quot;)?&#39;&amp;&#39;:&#39;?&#39;; url+=`${name}=${value}`; return url; } url = addUrlParam(url,&#39;c&#39;,&#39;fe&#39;); console.log(url); 补全字符串长度 padStart() padEnd() 第一个参数 补全后的总个数 第二个参数 要补全的内容 注意事项 第一个参数 少于原字符串的长度 则不会生效 返回原来的字符串 console.log(&#39;xxx&#39;.padStart(2,&#39;ab&#39;)); //不会生效 返回原来字符串 xxx 如果第二个参数不填的话自动补全空格 应用 数字前面不够位数补0 console.log(&#39;1&#39;.padStart(2,&#39;0&#39;)); 清除字符串的首尾空格 trimStart() 清除前面空格 trimEnd() 清除后面空格 trim()清除前后空格 let b = &#39; a &#39;; console.log(b.trimStart()); 数组的新增方法includes() 第一个参数 要判断的元素 第二个参数 从哪个位置开始 默认是从0 console.log([1,2,3].includes(2));//true 应用 去重 const a = o=&gt;{ const n =[]; for (const i of o) { if(!n.includes(i)){ n.push(i); } } return n; } let arr=a([1,2,2,2,3,4,5,5,6,3,2]); console.log(arr); 将其他数据类型转化为数组 Array.from(); 第一参数 要转换为数组的的数据 只要可遍历的的都可以转换成数组 数组 字符串 set map nodelist arguments console.log(Array.from(&quot;str&quot;)); 拥有length属性的对象可以转换成数组 const obj={ &#39;0&#39;:&quot;a&quot;, &#39;1&#39;:&#39;b&#39;, length:2 }; console.log(Array.from(obj)); 第二个参数 是个回调函数 对转换成数组的数据二次处理 console.log(Array.from(&#39;12&#39;,value=&gt;value*2)); 第三个参数是 决定this的指向 find() 找到满足条件的一个立即返回 console.log([1,2,3,4,5,6].find((value,index,arr)=&gt;{retrun value&gt;3;}));//4 findIndex() 找到满足条件的立即返回下标 console.log([1,2,3,4,5,6].find((value,index,arr)=&gt;{retrun value&gt;3;}));//3 应用 const students=[ { name:&#39;aaa&#39;, sex:&#39;男&#39;, age:16 }, { name:&#39;bbb&#39;, sex:&#39;女&#39;, age:16 }, { name:&#39;aaaddd&#39;, sex:&#39;男&#39;, age:16 } ] console.log(students.find(value=&gt;value.sex===&#39;女&#39;)); //返回sex为女的数据 对象的新增方法Object.assign() 第一个参数 目标对象 第二个参数 源对象 用于合并对象 const apple ={ color:&#39;red&#39;, shape:&#39;c&#39;, taste:&#39;dd&#39; } const pen ={ color:&#39;blue&#39;, shape:&#39;c&#39;, taste:&#39;dd&#39; } console.log(Object.assign(apple,pen));//把apple和pen合并为一个对象并且赋值给apple Object.keys() //返回键 Object.values() // 返回值 Object.entries() //返回键和值 和数组的keys() values() entries() 的区别 数组返回的是iterator 对象是返回数组 const apple ={ color:&#39;red&#39;, shape:&#39;c&#39;, taste:&#39;dd&#39; } console.log(object.values(apple)); //[red,c,dd]","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.lovelves.cn/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://www.lovelves.cn/tags/ES6/"},{"name":"前端笔记","slug":"前端笔记","permalink":"https://www.lovelves.cn/tags/前端笔记/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"springmvc_03","slug":"springmvc-day03","date":"2021-06-15T04:02:56.000Z","updated":"2021-06-16T06:47:42.000Z","comments":true,"path":"2021/06/15/springmvc-day03/","link":"","permalink":"https://www.lovelves.cn/2021/06/15/springmvc-day03/","excerpt":"","text":"SpringMVC的文件上传1-SpringMVC的请求-文件上传-客户端表单实现(应用)文件上传客户端表单需要满足： 表单项type=“file” 表单的提交方式是post 表单的enctype属性是多部分表单形式，及enctype=“multipart/form-data” &lt;form action=&quot;${pageContext.request.contextPath}/user/quick22&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 文件1&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; 2-SpringMVC的请求-文件上传-文件上传的原理(理解) 3-SpringMVC的请求-文件上传-单文件上传的代码实现1(应用)添加依赖 &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; 配置多媒体解析器 &lt;!--配置文件上传解析器--&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UYF-8&quot;/&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;500000&quot;/&gt; &lt;/bean&gt; 后台程序 @RequestMapping(value=&quot;/quick22&quot;) @ResponseBody public void save22(String username, MultipartFile uploadFile) throws IOException { System.out.println(username); System.out.println(uploadFile); } 4-SpringMVC的请求-文件上传-单文件上传的代码实现2(应用)完成文件上传 @RequestMapping(value=&quot;/quick22&quot;) @ResponseBody public void save22(String username, MultipartFile uploadFile) throws IOException { System.out.println(username); //获得上传文件的名称 String originalFilename = uploadFile.getOriginalFilename(); uploadFile.transferTo(new File(&quot;C:\\\\upload\\\\&quot;+originalFilename)); } 5-SpringMVC的请求-文件上传-多文件上传的代码实现(应用)多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[]即可 &lt;form action=&quot;${pageContext.request.contextPath}/user/quick23&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 文件1&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br/&gt; 文件2&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; @RequestMapping(value=&quot;/quick23&quot;) @ResponseBody public void save23(String username, MultipartFile[] uploadFile) throws IOException { System.out.println(username); for (MultipartFile multipartFile : uploadFile) { String originalFilename = multipartFile.getOriginalFilename(); multipartFile.transferTo(new File(&quot;C:\\\\upload\\\\&quot;+originalFilename)); } } 6-SpringMVC的请求-知识要点(理解，记忆) SpringMVC的拦截器01-SpringMVC拦截器-拦截器的作用(理解)Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（InterceptorChain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。 02-SpringMVC拦截器-interceptor和filter区别(理解，记忆)关于interceptor和filter的区别，如图所示： 03-SpringMVC拦截器-快速入门(应用)自定义拦截器很简单，只有如下三步： ①创建拦截器类实现HandlerInterceptor接口 ②配置拦截器 ③测试拦截器的拦截效果 编写拦截器： public class MyInterceptor1 implements HandlerInterceptor { //在目标方法执行之前 执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException { System.out.println(&quot;preHandle.....&quot;); } //在目标方法执行之后 视图对象返回之前执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { System.out.println(&quot;postHandle...&quot;); } //在流程都执行完毕后 执行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { System.out.println(&quot;afterCompletion....&quot;); } } 配置：在SpringMVC的配置文件中配置 &lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 编写测试程序测试： 编写Controller,发请求到controller,跳转页面 @Controller public class TargetController { @RequestMapping(&quot;/target&quot;) public ModelAndView show(){ System.out.println(&quot;目标资源执行......&quot;); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;name&quot;,&quot;itcast&quot;); modelAndView.setViewName(&quot;index&quot;); return modelAndView; } } 页面 &lt;html&gt; &lt;body&gt; &lt;h2&gt;Hello World! ${name}&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; 04-SpringMVC拦截器-快速入门详解(应用)拦截器在预处理后什么情况下会执行目标资源，什么情况下不执行目标资源，以及在有多个拦截器的情况下拦截器的执行顺序是什么? 再编写一个拦截器2， public class MyInterceptor2 implements HandlerInterceptor { //在目标方法执行之前 执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException { System.out.println(&quot;preHandle22222.....&quot;); return true; } //在目标方法执行之后 视图对象返回之前执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { System.out.println(&quot;postHandle2222...&quot;); } //在流程都执行完毕后 执行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { System.out.println(&quot;afterCompletion2222....&quot;); } } 配置拦截器2 &lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyInterceptor2&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 结论： 当拦截器的preHandle方法返回true则会执行目标资源，如果返回false则不执行目标资源 多个拦截器情况下，配置在前的先执行，配置在后的后执行 拦截器中的方法执行顺序是：preHandler——-目标资源—-postHandle—- afterCompletion 05-SpringMVC拦截器-知识小结(记忆)拦截器中的方法说明如下 06-SpringMVC拦截器-用户登录权限控制分析(理解)在day06-Spring练习案例的基础之上：用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登录页面，只有用户登录成功后才能进行后台功能的操作 需求图： 07-SpringMVC拦截器-用户登录权限控制代码实现1(应用)判断用户是否登录 本质：判断session中有没有user，如果没有登陆则先去登陆，如果已经登陆则直接放行访问目标资源 先编写拦截器如下： public class PrivilegeInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException { //逻辑：判断用户是否登录 本质：判断session中有没有user HttpSession session = request.getSession(); User user = (User) session.getAttribute(&quot;user&quot;); if(user==null){ //没有登录 response.sendRedirect(request.getContextPath()+&quot;/login.jsp&quot;); return false; } //放行 访问目标资源 return true; } } 然后配置该拦截器：找到项目案例的spring-mvc.xml，添加如下配置： &lt;!--配置权限拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.PrivilegeInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 08-SpringMVC拦截器-用户登录权限控制代码实现2(应用)在登陆页面输入用户名密码，点击登陆，通过用户名密码进行查询，如果登陆成功，则将用户信息实体存入session，然后跳转到首页，如果登陆失败则继续回到登陆页面 在UserController中编写登陆逻辑 @RequestMapping(&quot;/login&quot;) public String login(String username,String password,HttpSession session){ User user = userService.login(username,password); if(user!=null){ //登录成功 将user存储到session session.setAttribute(&quot;user&quot;,user); return &quot;redirect:/index.jsp&quot;; } return &quot;redirect:/login.jsp&quot;; } service层代码如下： //service层 public User login(String username, String password) { User user = userDao.findByUsernameAndPassword(username,password); return user; } dao层代码如下： //dao层 public User findByUsernameAndPassword(String username, String password) throws EmptyResultDataAccessException{ User user = jdbcTemplate.queryForObject(&quot;select * from sys_user where username=? and password=?&quot;, new BeanPropertyRowMapper&lt;User&gt;(User.class), username, password); return user; } 此时仍然登陆不上，因为我们需要将登陆请求url让拦截器放行,添加资源排除的配置 &lt;!--配置权限拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--配置哪些资源排除拦截操作--&gt; &lt;mvc:exclude-mapping path=&quot;/user/login&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.PrivilegeInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 09-SpringMVC拦截器-用户登录权限控制代码实现3(应用)JdbcTemplate.queryForObject对象如果查询不到数据会抛异常，导致程序无法达到预期效果，如何来解决该问题？ 在业务层处理来自dao层的异常，如果出现异常service层返回null,而不是将异常抛给controller 因此改造登陆的业务层代码,添加异常的控制 public User login(String username, String password) { try { User user = userDao.findByUsernameAndPassword(username,password); return user; }catch (EmptyResultDataAccessException e){ return null; } } 1. SpringMVC异常处理机制1.1 异常处理的思路系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。 系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图： 1.2 异常处理两种方式① 使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver ② 实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器 1.3 简单异常处理器SimpleMappingExceptionResolverSpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置 &lt;!--配置简单映射异常处理器--&gt; &lt;bean class=“org.springframework.web.servlet.handler.SimpleMappingExceptionResolver”&gt; &lt;property name=“defaultErrorView” value=“error”/&gt; 默认错误视图 &lt;property name=“exceptionMappings”&gt; &lt;map&gt; 异常类型 错误视图 &lt;entry key=&quot;com.itheima.exception.MyException&quot; value=&quot;error&quot;/&gt; &lt;entry key=&quot;java.lang.ClassCastException&quot; value=&quot;error&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 1.4 自定义异常处理步骤①创建异常处理器类实现HandlerExceptionResolver public class MyExceptionResolver implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { //处理异常的代码实现 //创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&quot;exceptionPage&quot;); return modelAndView; } } ②配置异常处理器 &lt;bean id=&quot;exceptionResolver&quot; class=&quot;com.itheima.exception.MyExceptionResolver&quot;/&gt; ③编写异常页面 &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 这是一个最终异常的显示页面 &lt;/body&gt; &lt;/html&gt; ④测试异常跳转 @RequestMapping(&quot;/quick22&quot;) @ResponseBody public void quickMethod22() throws IOException, ParseException { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); simpleDateFormat.parse(&quot;abcde&quot;); } 1.5 知识要点异常处理方式 配置简单异常处理器SimpleMappingExceptionResolver 自定义异常处理器 自定义异常处理步骤 ①创建异常处理器类实现HandlerExceptionResolver ②配置异常处理器 ③编写异常页面 ④测试异常跳转 ###","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.lovelves.cn/tags/springboot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"Spring与Web环境集成","slug":"Spring与Web环境集成","date":"2021-06-15T00:41:08.000Z","updated":"2021-06-16T06:39:56.000Z","comments":true,"path":"2021/06/15/Spring与Web环境集成/","link":"","permalink":"https://www.lovelves.cn/2021/06/15/Spring与Web环境集成/","excerpt":"","text":"1. Spring与Web环境集成1.1 ApplicationContext应用上下文获取方式应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。 在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。 1.2 Spring提供获取应用上下文的工具上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。 所以我们需要做的只有两件事： ①在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标） ②使用WebApplicationContextUtils获得应用上下文对象ApplicationContext 1.3 导入Spring集成web的坐标&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 1.4 配置ContextLoaderListener监听器&lt;!--全局参数--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--Spring的监听器--&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; 1.5 通过工具获得应用上下文对象ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext); Object obj = applicationContext.getBean(&quot;id&quot;); 知识要点 Spring集成web环境步骤 ​ ①配置ContextLoaderListener监听器 ​ ②使用WebApplicationContextUtils获得应用上下文 2. SpringMVC的简介2.1 SpringMVC概述SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。 SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。 2.3 SpringMVC快速入门需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。 开发步骤 ①导入SpringMVC相关坐标 ②配置SpringMVC核心控制器DispathcerServlet ③创建Controller类和视图页面 ④使用注解配置Controller类中业务方法的映射地址 ⑤配置SpringMVC核心文件 spring-mvc.xml ⑥客户端发起请求测试 代码实现 ①导入Spring和SpringMVC的坐标、导入Servlet和Jsp的坐标 &lt;!--Spring坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringMVC坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--Jsp坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; ②在web.xml配置SpringMVC的核心控制器 &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; ③创建Controller和业务方法 public class QuickController { public String quickMethod(){ System.out.println(&quot;quickMethod running.....&quot;); return &quot;index&quot;; } } ③创建视图页面index.jsp &lt;html&gt; &lt;body&gt; &lt;h2&gt;Hello SpringMVC!&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; ④配置注解 @Controller public class QuickController { @RequestMapping(&quot;/quick&quot;) public String quickMethod(){ System.out.println(&quot;quickMethod running.....&quot;); return &quot;index&quot;; } } ⑤创建spring-mvc.xml &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--配置注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt; &lt;/beans&gt; ⑥访问测试地址 http://localhost:8080/itheima_springmvc1/quick 控制台打印 页面显示 2.3 SpringMVC流程图示 2.4 知识要点SpringMVC的开发步骤 ①导入SpringMVC相关坐标 ②配置SpringMVC核心控制器DispathcerServlet ③创建Controller类和视图页面 ④使用注解配置Controller类中业务方法的映射地址 ⑤配置SpringMVC核心文件 spring-mvc.xml ⑥客户端发起请求测试 3. SpringMVC的组件解析3.1 SpringMVC的执行流程 ①用户发送请求至前端控制器DispatcherServlet。 ②DispatcherServlet收到请求调用HandlerMapping处理器映射器。 ③处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 ④DispatcherServlet调用HandlerAdapter处理器适配器。 ⑤HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 ⑥Controller执行完成返回ModelAndView。 ⑦HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 ⑧DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 ⑨ViewReslover解析后返回具体View。 ⑩DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。 3.2 SpringMVC组件解析 前端控制器：DispatcherServlet ​ 用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 处理器映射器：HandlerMapping ​ HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。 处理器适配器：HandlerAdapter ​ 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。 处理器：Handler ​ 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。 视图解析器：View Resolver ​ View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 视图：View ​ SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面 3.3 SpringMVC注解解析@RequestMapping 作用：用于建立请求 URL 和处理请求方法之间的对应关系 位置： ​ 类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录 ​ 方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径 属性： ​ value：用于指定请求的URL。它和path属性的作用是一样的 ​ method：用于指定请求的方式 ​ params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样 例如： ​ params = {“accountName”}，表示请求参数必须有accountName ​ params = {“moeny!100”}，表示请求参数中money不能是100 1.mvc命名空间引入 命名空间：xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; 约束地址：http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd 2.组件扫描 SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;context:component-scan base-package=“com.itheima.controller”/&gt;进行组件扫描。 3.4 SpringMVC的XML配置解析SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下： org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver 翻看该解析器源码，可以看到该解析器的默认设置，如下： REDIRECT_URL_PREFIX = &quot;redirect:&quot; --重定向前缀 FORWARD_URL_PREFIX = &quot;forward:&quot; --转发前缀（默认值） prefix = &quot;&quot;; --视图名称前缀 suffix = &quot;&quot;; --视图名称后缀 视图解析器 我们可以通过属性注入的方式修改视图的的前后缀 &lt;!--配置内部资源视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 3.5 知识要点SpringMVC的相关组件 前端控制器：DispatcherServlet 处理器映射器：HandlerMapping 处理器适配器：HandlerAdapter 处理器：Handler 视图解析器：View Resolver 视图：View SpringMVC的注解和配置 请求映射注解：@RequestMapping 视图解析器配置： REDIRECT_URL_PREFIX = “redirect:” FORWARD_URL_PREFIX = “forward:” prefix = “”; suffix = “”;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.lovelves.cn/tags/springboot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"springmvc02","slug":"springmvc02","date":"2021-06-15T00:41:08.000Z","updated":"2021-06-16T06:40:02.000Z","comments":true,"path":"2021/06/15/springmvc02/","link":"","permalink":"https://www.lovelves.cn/2021/06/15/springmvc02/","excerpt":"","text":"SpringMVC的请求和响应SpringMVC的数据响应01-SpringMVC的数据响应-数据响应方式(理解)1) 页面跳转 直接返回字符串 通过ModelAndView对象返回 2） 回写数据 直接返回字符串 返回对象或集合 02-SpringMVC的数据响应-页面跳转-返回字符串形式（应用） 03-SpringMVC的数据响应-页面跳转-返回ModelAndView形式1(应用)在Controller中方法返回ModelAndView对象，并且设置视图名称 @RequestMapping(value=&quot;/quick2&quot;) public ModelAndView save2(){ /* Model:模型 作用封装数据 View：视图 作用展示数据 */ ModelAndView modelAndView = new ModelAndView(); //设置模型数据 modelAndView.addObject(&quot;username&quot;,&quot;itcast&quot;); //设置视图名称 modelAndView.setViewName(&quot;success&quot;); return modelAndView; } 04-SpringMVC的数据响应-页面跳转-返回ModelAndView形式2(应用)n在Controller中方法形参上直接声明ModelAndView，无需在方法中自己创建，在方法中直接使用该对象设置视图，同样可以跳转页面 @RequestMapping(value=&quot;/quick3&quot;) public ModelAndView save3(ModelAndView modelAndView){ modelAndView.addObject(&quot;username&quot;,&quot;itheima&quot;); modelAndView.setViewName(&quot;success&quot;); return modelAndView; } @RequestMapping(value=&quot;/quick4&quot;) public String save4(Model model){ model.addAttribute(&quot;username&quot;,&quot;博学谷&quot;); return &quot;success&quot;; } 05-SpringMVC的数据响应-页面跳转-返回ModelAndView3(应用)在Controller方法的形参上可以直接使用原生的HttpServeltRequest对象，只需声明即可 @RequestMapping(value=&quot;/quick5&quot;) public String save5(HttpServletRequest request){ request.setAttribute(&quot;username&quot;,&quot;酷丁鱼&quot;); return &quot;success&quot;; } 06-SpringMVC的数据响应-回写数据-直接回写字符串(应用)通过SpringMVC框架注入的response对象，使用response.getWriter().print(“hello world”) 回写数据，此时不需要视图跳转，业务方法返回值为void 将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回 @RequestMapping(value=&quot;/quick7&quot;) @ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应 public String save7() throws IOException { return &quot;hello itheima&quot;; } @RequestMapping(value=&quot;/quick6&quot;) public void save6(HttpServletResponse response) throws IOException { response.getWriter().print(&quot;hello itcast&quot;); } 07-SpringMVC的数据响应-回写数据-直接回写json格式字符串(应用)@RequestMapping(value=&quot;/quick8&quot;) @ResponseBody public String save8() throws IOException { return &quot;{\\&quot;username\\&quot;:\\&quot;zhangsan\\&quot;,\\&quot;age\\&quot;:18}&quot;; } 手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换,通过jackson转换json格式字符串，回写字符串 @RequestMapping(value=&quot;/quick9&quot;) @ResponseBody public String save9() throws IOException { User user = new User(); user.setUsername(&quot;lisi&quot;); user.setAge(30); //使用json的转换工具将对象转换成json格式字符串在返回 ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(user); return json; } 08-SpringMVC的数据响应-回写数据-返回对象或集合(应用)通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置： &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; @RequestMapping(value=&quot;/quick10&quot;) @ResponseBody //期望SpringMVC自动将User转换成json格式的字符串 public User save10() throws IOException { User user = new User(); user.setUsername(&quot;lisi2&quot;); user.setAge(32); return user; } 09-SpringMVC的数据响应-回写数据-返回对象或集合2(应用)在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置 &lt;mvc:annotation-driven/&gt; 在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。 使用&lt;mvc:annotation-driven /&gt;自动加载 RequestMappingHandlerMapping（处理映射器）和 RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在Spring-xml.xml配置文件中使用 &lt;mvc:annotation-driven /&gt;替代注解处理器和适配器的配置。 同时使用&lt;mvc:annotation-driven /&gt; 默认底层就会集成jackson进行对象或集合的json格式字符串的转换 10-SpringMVC的数据响应-知识要点小结(理解，记忆)1） 页面跳转 直接返回字符串 通过ModelAndView对象返回 2） 回写数据 直接返回字符串 HttpServletResponse 对象直接写回数据，HttpServletRequest对象带回数据，Model对象带回数据或者@ResponseBody将字符串数据写回 返回对象或集合 @ResponseBody+&lt;mvc:annotation-driven/&gt; SpringMVC的请求11-SpringMVC的请求-获得请求参数-请求参数类型(理解)客户端请求参数的格式是：name=value&amp;name=value…… 服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数 基本类型参数 POJO类型参数 数组类型参数 集合类型参数 12-SpringMVC的请求-获得请求参数-获得基本类型参数(应用)Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换； 自动的类型转换是指从String向其他类型的转换 http://localhost:8080/itheima_springmvc1/quick9?username=zhangsan&amp;age=12 @RequestMapping(value=&quot;/quick11&quot;) @ResponseBody public void save11(String username,int age) throws IOException { System.out.println(username); System.out.println(age); } 13-SpringMVC的请求-获得请求参数-获得POJO类型参数(应用)Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。 package com.itheima.domain; public class User { private String username; private int age; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;User{&quot; + &quot;username=&#39;&quot; + username + &#39;\\&#39;&#39; + &quot;, age=&quot; + age + &#39;}&#39;; } } @RequestMapping(value=&quot;/quick12&quot;) @ResponseBody public void save12(User user) throws IOException { System.out.println(user); } 14-SpringMVC的请求-获得请求参数-获得数组类型参数(应用)Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。 @RequestMapping(value=&quot;/quick13&quot;) @ResponseBody public void save13(String[] strs) throws IOException { System.out.println(Arrays.asList(strs)); } 15-SpringMVC的请求-获得请求参数-获得集合类型参数1(应用)获得集合参数时，要将集合参数包装到一个POJO中才可以。 &lt;form action=&quot;${pageContext.request.contextPath}/user/quick14&quot; method=&quot;post&quot;&gt; &lt;%--表明是第一个User对象的username age--%&gt; &lt;input type=&quot;text&quot; name=&quot;userList[0].username&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;userList[0].age&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;userList[1].username&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;userList[1].age&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; package com.itheima.domain; import java.util.List; public class VO { private List&lt;User&gt; userList; public List&lt;User&gt; getUserList() { return userList; } public void setUserList(List&lt;User&gt; userList) { this.userList = userList; } @Override public String toString() { return &quot;VO{&quot; + &quot;userList=&quot; + userList + &#39;}&#39;; } } @RequestMapping(value=&quot;/quick14&quot;) @ResponseBody public void save14(VO vo) throws IOException { System.out.println(vo); } 16-SpringMVC的请求-获得请求参数-获得集合类型参数2(应用)当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装 &lt;script src=&quot;${pageContext.request.contextPath}/js/jquery-3.3.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var userList = new Array(); userList.push({username:&quot;zhangsan&quot;,age:18}); userList.push({username:&quot;lisi&quot;,age:28}); $.ajax({ type:&quot;POST&quot;, url:&quot;${pageContext.request.contextPath}/user/quick15&quot;, data:JSON.stringify(userList), contentType:&quot;application/json;charset=utf-8&quot; }); &lt;/script&gt; @RequestMapping(value=&quot;/quick15&quot;) @ResponseBody public void save15(@RequestBody List&lt;User&gt; userList) throws IOException { System.out.println(userList); } 17-SpringMVC的请求-获得请求参数-静态资源访问的开启(应用)当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源： •在spring-mvc.xml配置文件中指定放行的资源 ​ &lt;mvc:resources mapping=&quot;/js/**&quot;location=&quot;/js/&quot;/&gt; •使用&lt;mvc:default-servlet-handler/&gt;标签 &lt;!--开发资源的访问--&gt; &lt;!--&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt; &lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;/&gt;--&gt; &lt;mvc:default-servlet-handler/&gt; 18-SpringMVC的请求-获得请求参数-配置全局乱码过滤器(应用)当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。 &lt;!--配置全局过滤的filter--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 19-SpringMVC的请求-获得请求参数-参数绑定注解@RequestParam(应用)当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定 &lt;form action=&quot;${pageContext.request.contextPath}/quick16&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt; &lt;/form&gt; @RequestMapping(value=&quot;/quick16&quot;) @ResponseBody public void save16(@RequestParam(value=&quot;name&quot;,required = false,defaultValue = &quot;itcast&quot;) String username) throws IOException { System.out.println(username); } 20-SpringMVC的请求-获得请求参数-Restful风格的参数的获取(应用)Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。 Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下： GET：用于获取资源 POST：用于新建资源 PUT：用于更新资源 DELETE：用于删除资源 例如： /user/1 GET ： 得到 id = 1 的 user /user/1 DELETE： 删除 id = 1 的 user /user/1 PUT： 更新 id = 1 的 user /user POST： 新增 user 上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。 http://localhost:8080/itheima_springmvc1/quick17/zhangsan @RequestMapping(value=&quot;/quick17/{name}&quot;) @ResponseBody public void save17(@PathVariable(value=&quot;name&quot;) String username) throws IOException { System.out.println(username); } 21-SpringMVC的请求-获得请求参数-自定义类型转换器(应用)SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。 但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。 public class DateConverter implements Converter&lt;String, Date&gt; { public Date convert(String dateStr) { //将日期字符串转换成日期对象 返回 SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = null; try { date = format.parse(dateStr); } catch (ParseException e) { e.printStackTrace(); } return date; } } @RequestMapping(value=&quot;/quick18&quot;) @ResponseBody public void save18(Date date) throws IOException { System.out.println(date); } 22-SpringMVC的请求-获得请求参数-获得Servlet相关API(应用)SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下： HttpServletRequest HttpServletResponse HttpSession @RequestMapping(value=&quot;/quick19&quot;) @ResponseBody public void save19(HttpServletRequest request, HttpServletResponse response, HttpSession session) throws IOException { System.out.println(request); System.out.println(response); System.out.println(session); } 23-SpringMVC的请求-获得请求参数-获得请求头信息(应用)使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name) @RequestHeader注解的属性如下： value：请求头的名称 required：是否必须携带此请求头 @RequestMapping(value=&quot;/quick20&quot;) @ResponseBody public void save20(@RequestHeader(value = &quot;User-Agent&quot;,required = false) String user_agent) throws IOException { System.out.println(user_agent); } 使用@CookieValue可以获得指定Cookie的值 @CookieValue注解的属性如下： value：指定cookie的名称 required：是否必须携带此cookie @RequestMapping(value=&quot;/quick21&quot;) @ResponseBody public void save21(@CookieValue(value = &quot;JSESSIONID&quot;) String jsessionId) throws IOException { System.out.println(jsessionId); }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.lovelves.cn/tags/springboot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"酷我音乐爬取","slug":"酷我音乐爬取","date":"2021-06-15T00:41:08.000Z","updated":"2021-06-18T11:12:08.005Z","comments":true,"path":"2021/06/15/酷我音乐爬取/","link":"","permalink":"https://www.lovelves.cn/2021/06/15/酷我音乐爬取/","excerpt":"","text":"酷我音乐爬虫主要接口获取歌曲下载地址 http://www.kuwo.cn/url?format=mp3&amp;rid=173345979&amp;response=url&amp;type=convert_url3&amp;br=320kmp3&amp;from=web&amp;t=1623843977328&amp;httpsStatus=1 获取结果url 是歌曲的下载地址 {&quot;code&quot;: 200, &quot;msg&quot;: &quot;success&quot;, &quot;url&quot;: &quot;https://gv-sycdn.kuwo.cn/8ee6ee8edbbafa235e08991ac4382519/60c9e6b6/resource/n2/30/9/3326431231.mp3&quot;} 主要参数rid 歌曲的idbr 歌曲的码率 320是最高码率t 时间戳用python 拼凑参数 base_url = &#39;http://www.kuwo.cn/url&#39; params = { &#39;format&#39;: &#39;mp3&#39;, &#39;rid&#39;: rid, &#39;response&#39;: &#39;url&#39;, &#39;type&#39;: &#39;convert_url3&#39;, &#39;br&#39;: &#39;320kmp3&#39;, # 320K 代表是无陨音质。 &#39;from&#39;: &#39;web&#39;, &#39;t&#39;: str(int(time.time() * 1000)), &#39;httpsStatus&#39;: &#39;1&#39; } 获取歌曲rid http://www.kuwo.cn/api/www/search/searchMusicBykeyWord?key=%E9%99%88%E6%85%A7%E7%90%B3&amp;pn=1&amp;rn=30&amp;httpsStatus=1 主要参数key 你要得歌曲或者作者得名字pn 当前得页数rn 一页显示多少首 请求时header需要的参数CookieUser-Agent 浏览器表示csrf Cookie中的kw_token的值Host 主域名Referer 来源 获取结果rid 歌曲的ID name 歌曲名字 songTimeMinutes 歌曲的时长 { &quot;code&quot;: 200, &quot;curTime&quot;: 1623845910234, &quot;data&quot;: { &quot;total&quot;: &quot;1577&quot;, &quot;list&quot;: [ { &quot;musicrid&quot;: &quot;MUSIC_7165139&quot;, &quot;barrage&quot;: &quot;0&quot;, &quot;artist&quot;: &quot;卢冠廷&amp;张智霖&amp;成龙&amp;许冠杰&amp;陈慧琳&amp;陈慧娴&amp;李克勤&amp;G.E.M.邓紫棋&amp;张学友&amp;陈奕迅&amp;谭咏麟&quot;, &quot;mvpayinfo&quot;: { &quot;play&quot;: &quot;0&quot;, &quot;vid&quot;: &quot;3991780&quot;, &quot;download&quot;: &quot;0&quot; }, &quot;pic&quot;: &quot;https://img4.kuwo.cn/star/albumcover/120/26/5/2778776974.jpg&quot;, &quot;isstar&quot;: 0, &quot;rid&quot;: 7165139, &quot;duration&quot;: 255, &quot;score100&quot;: &quot;79&quot;, &quot;content_type&quot;: &quot;0&quot;, &quot;track&quot;: 0, &quot;hasLossless&quot;: false, &quot;hasmv&quot;: 1, &quot;album&quot;: &quot;真的英雄&quot;, &quot;albumid&quot;: &quot;558959&quot;, &quot;pay&quot;: &quot;0&quot;, &quot;artistid&quot;: 690, &quot;albumpic&quot;: &quot;https://img4.kuwo.cn/star/albumcover/120/26/5/2778776974.jpg&quot;, &quot;originalsongtype&quot;: 1, &quot;songTimeMinutes&quot;: &quot;04:15&quot;, &quot;isListenFee&quot;: false, &quot;pic120&quot;: &quot;https://img4.kuwo.cn/star/albumcover/120/26/5/2778776974.jpg&quot;, &quot;name&quot;: &quot;真的英雄&quot;, &quot;online&quot;: 1, &quot;payInfo&quot;: { &quot;play&quot;: &quot;0000&quot;, &quot;download&quot;: &quot;0000&quot;, &quot;local_encrypt&quot;: &quot;0&quot;, &quot;limitfree&quot;: &quot;0&quot;, &quot;cannotDownload&quot;: &quot;0&quot;, &quot;cannotOnlinePlay&quot;: &quot;0&quot;, &quot;feeType&quot;: { &quot;song&quot;: &quot;0&quot;, &quot;album&quot;: &quot;0&quot;, &quot;vip&quot;: &quot;0&quot;, &quot;bookvip&quot;: &quot;0&quot; }, &quot;listen_fragment&quot;: &quot;0&quot;, &quot;tips_intercept&quot;: &quot;0&quot; } }, { &quot;musicrid&quot;: &quot;MUSIC_86371&quot;, &quot;barrage&quot;: &quot;0&quot;, &quot;artist&quot;: &quot;陈慧琳&quot;, &quot;mvpayinfo&quot;: { &quot;play&quot;: &quot;0&quot;, &quot;vid&quot;: &quot;253402&quot;, &quot;download&quot;: &quot;0&quot; }, &quot;pic&quot;: &quot;https://img4.kuwo.cn/star/albumcover/120/70/38/3191802684.jpg&quot;, &quot;isstar&quot;: 0, &quot;rid&quot;: 86371, &quot;duration&quot;: 247, &quot;score100&quot;: &quot;79&quot;, &quot;content_type&quot;: &quot;0&quot;, &quot;track&quot;: 0, &quot;hasLossless&quot;: false, &quot;hasmv&quot;: 1, &quot;album&quot;: &quot;闪亮每一天Shining&amp;nbsp;新歌&amp;nbsp;+&amp;nbsp;精选&quot;, &quot;albumid&quot;: &quot;24050&quot;, &quot;pay&quot;: &quot;16515324&quot;, &quot;artistid&quot;: 871, &quot;albumpic&quot;: &quot;https://img4.kuwo.cn/star/albumcover/120/70/38/3191802684.jpg&quot;, &quot;originalsongtype&quot;: 0, &quot;songTimeMinutes&quot;: &quot;04:07&quot;, &quot;isListenFee&quot;: false, &quot;pic120&quot;: &quot;https://img4.kuwo.cn/star/albumcover/120/70/38/3191802684.jpg&quot;, &quot;name&quot;: &quot;记事本-选自“我的秘密花园2”&quot;, &quot;online&quot;: 1, &quot;payInfo&quot;: { &quot;play&quot;: &quot;1100&quot;, &quot;download&quot;: &quot;1111&quot;, &quot;local_encrypt&quot;: &quot;1&quot;, &quot;limitfree&quot;: &quot;0&quot;, &quot;cannotDownload&quot;: &quot;0&quot;, &quot;cannotOnlinePlay&quot;: &quot;0&quot;, &quot;feeType&quot;: { &quot;song&quot;: &quot;1&quot;, &quot;album&quot;: &quot;0&quot;, &quot;vip&quot;: &quot;1&quot;, &quot;bookvip&quot;: &quot;0&quot; }, &quot;listen_fragment&quot;: &quot;0&quot;, &quot;tips_intercept&quot;: &quot;0&quot; } }, python实战熟悉以上接口就好办了 在网上爬了份不错的参考代码 如下 import time, os, requests, threading, re, multiprocessing from multiprocessing import Pool class KuwoMusic: def __init__(self,cookie): self.cookie = cookie def get_music_url(self, rid): # http://www.kuwo.cn/url?format=mp3&amp;rid=440613&amp;response=url&amp;type=convert_url3&amp;br=320kmp3&amp;from=web&amp;t=1620179066636&amp;httpsStatus=1 base_url = &#39;http://www.kuwo.cn/url&#39; params = { &#39;format&#39;: &#39;mp3&#39;, &#39;rid&#39;: rid, &#39;response&#39;: &#39;url&#39;, &#39;type&#39;: &#39;convert_url3&#39;, &#39;br&#39;: &#39;320kmp3&#39;, # 320K 代表是无陨音质。 &#39;from&#39;: &#39;web&#39;, &#39;t&#39;: str(int(time.time() * 1000)), &#39;httpsStatus&#39;: &#39;1&#39; } headers = { &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Host&#39;: &#39;www.kuwo.cn&#39;, &#39;Referer&#39;: &#39;http://www.kuwo.cn/search/list&#39;, &#39;Cookie&#39;: self.cookie, &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&#39; } resp = requests.get(url=base_url, params=params, headers=headers) music_url = resp.json().get(&quot;url&quot;) return music_url def music_download(self, url, name): host = re.findall(&#39;https://(.*?)/&#39;, url)[0] headers = { &#39;Accept&#39;: &#39;*/*&#39;, &#39;sec-ch-ua&#39;: &#39;&quot; Not A;Brand&quot;;v = &quot;99&quot;, &quot;Chromium&quot;;v = &quot;90&quot;, &quot;Google Chrome&quot;;v = &quot;90&quot;&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Host&#39;: host, &#39;Referer&#39;: url, &#39;Cookie&#39;: self.cookie, &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&#39; } print(name + &quot;.mp3\\t开始下载...&quot;) data = requests.get(url=url, headers=headers).content try: if not os.path.exists(&quot;音乐下载&quot;): os.mkdir(&quot;音乐下载&quot;) except: pass filepath = &quot;音乐下载/&quot; + name + &#39;.mp3&#39; with open(filepath, &#39;wb&#39;) as f: f.write(data) print(name + &quot;.mp3\\t下载完成.&quot;) def get_music_list(self, key, pn): # http://www.kuwo.cn/api/www/search/searchMusicBykeyWord?key=%E5%91%A8%E6%9D%B0%E4%BC%A6&amp;pn=1&amp;rn=30&amp;httpsStatus=1&amp;reqId=1aee48d0-ad43-11eb-b9fa-5f2f406dcb43 base_url = &#39;http://www.kuwo.cn/api/www/search/searchMusicBykeyWord&#39; params = { &#39;key&#39;: key, &#39;pn&#39;: pn, &#39;rn&#39;: 30, &#39;httpsStatus&#39;: &#39;1&#39; } csrf = re.findall(&quot;kw_token=(.{11})&quot;, self.cookie)[0] headers = { &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Cookie&#39;: self.cookie, &#39;csrf&#39;: csrf, # 这个值是cookie 里面的 kw_token值 &#39;Host&#39;: &#39;www.kuwo.cn&#39;, &#39;Referer&#39;: &#39;http://www.kuwo.cn/search/list&#39;, &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36&#39; } resp = requests.get(url=base_url, params=params, headers=headers) music_data = [] if len(resp.text) &gt; 88: # 出错返回长度是84 music_list = resp.json() music_list = music_list[&#39;data&#39;][&#39;list&#39;] for music in music_list: artist = music[&#39;artist&#39;] # 歌曲演唱者 artist = self.rename_use(artist) name = music[&#39;name&#39;] name = self.rename_use(name) rid = music[&#39;rid&#39;] # 歌曲 rid duration = music[&#39;duration&#39;] # 这个值是歌曲时长，单位是 秒 duration = self.s_to_m(duration) music_data.append({&#39;name&#39;: name, &#39;artist&#39;: artist, &#39;rid&#39;: rid, &#39;duration&#39;: duration}) else: print(&quot;数据获取失败，请重试。&quot;) return music_data def reset_list(self, a): # 列表去重复数据， a 代表一下列表 c = [] for i in range(len(a)): b = a.pop() if b not in a: c.append(b) return c def rename_use(self, file_name): file_name = file_name.replace(&quot;\\\\&quot;, &#39;&#39;).replace(&quot;/&quot;, &#39;&#39;).replace(&quot;:&quot;, &#39;&#39;).replace(&quot;*&quot;, &#39;&#39;).replace(&quot;?&quot;, &#39;&#39;).replace( &#39;&quot;&#39;, &#39;&#39;).replace(&quot;&lt;&quot;, &#39;&#39;).replace(&quot;&gt;&quot;, &#39;&#39;).replace(&quot;|&quot;, &#39;&#39;).replace(&quot;&amp;nbsp;&quot;, &quot;&quot;) return file_name def s_to_m(self, s): m = int(s) / 60 a = m - int(m) b = a * 60 b = int(b) if int(b) &lt; 10: b = &quot;0&quot; + str(int(b)) ms = str(int(m)) + &quot;：&quot; + str(b) return ms def show_short(self, name): if len(name) &gt; 18: name = name[:18] + &quot;..&quot; return name def main(self): inp = input(&quot;请输入歌曲名或歌手：\\n&quot;) pn = 1 musics_all = [] while True: music_data = self.get_music_list(inp, pn=pn) if music_data: musics_all.append(music_data) # 在这里判断去重，也行。只是把去重方法写出来才想到， 唉！！ for i, music in enumerate(music_data): artist = music[&#39;artist&#39;] # 歌曲演唱者 artist = self.show_short(artist) name = music[&#39;name&#39;] name = self.show_short(name) rid = music[&#39;rid&#39;] # 歌曲 rid duration = music[&#39;duration&#39;] # 歌曲时长 单位 秒 songTimeMinutes print(f&quot;{i + 1}. {name} \\t演唱:{artist} \\t时长:{duration}&quot;) print(&quot;*&quot; * 40 + &quot; 华丽的分割线 &quot; + &quot;*&quot; * 40) if pn == 1: print(&quot;请选择下载方式： \\n1.按歌曲编号下载 \\t3.下一页\\t4.全部下载\\t 按0退出\\n&quot;) elif pn &gt; 1: print(&quot;请选择下载方式： \\n1.按歌曲编号下载 \\t2.上一页 \\t3.下一页\\t4.全部下载\\t 按0退出\\n&quot;) inp_b = input() if inp_b == &#39;1&#39;: while True: print(&quot;选择歌曲编号，加入下载..输入&#39;0&#39;, 退出&quot;) inp_c = input(&quot;&quot;) if int(inp_c) in [i for i in range(1, 31)]: rid = music_data[int(inp_c) - 1][&#39;rid&#39;] artist = music_data[int(inp_c) - 1][&#39;artist&#39;] name = music_data[int(inp_c) - 1][&#39;name&#39;] music_url = self.get_music_url(rid) music_name = name + &quot;-&quot; + artist th = threading.Thread(target=self.music_download, args=(music_url, music_name)) th.start() # th.join() print(&quot;添加成功，请继续&quot;) elif inp_c == &#39;0&#39;: print(&quot;成功退出&quot;) break else: print(&quot;输入有误,是对应歌曲的编号（1,4 或是 12）&quot;) time.sleep(3) elif inp_b == &#39;2&#39;: pn -= 1 if pn &lt;1: print(&quot;操作不当，请重试&quot;) pn = 1 elif inp_b == &#39;3&#39;: pn += 1 elif inp_b == &#39;4&#39;: musics_all = self.reset_list(musics_all) # 去除重复歌单 for musics in musics_all: for music in musics: rid = music[&#39;rid&#39;] artist = music[&#39;artist&#39;] name = music[&#39;name&#39;] music_url = self.get_music_url(rid) music_name = name + &quot;-&quot; + artist # print(music_name,music_url) # th = threading.Thread(target=self.music_download, args=(music_url, music_name)) # th.start() # th.join() pool.apply_async(self.music_download, args=(music_url, music_name)) pool.close() pool.join() print(&quot;下载完毕，程序即将退出&quot;) time.sleep(2) break elif inp_b == &#39;0&#39;: print(&#39;成功退出，程序即将关闭&#39;) time.sleep(2) break else: print(&quot;可能输入有误，可以重试&quot;) time.sleep(2) else: print(&quot;数据获取失败，或没有更多歌曲了&quot;) time.sleep(2) def get_cookie(): url = &#39;http://www.kuwo.cn/&#39; headers = { &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Host&#39;: &#39;www.kuwo.cn&#39;, &#39;Referer&#39;: &#39;http://www.kuwo.cn/&#39;, &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&#39; } res = requests.get(url=url, headers=headers) cookies = res.cookies.items() cookie = &#39;&#39; for name, value in cookies: cookie += &#39;{0}={1};&#39;.format(name, value) return cookie if __name__ == &#39;__main__&#39;: multiprocessing.freeze_support() pool = Pool(3) cookie = get_cookie() kuwo = KuwoMusic(cookie) kuwo.main()","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.lovelves.cn/tags/爬虫/"},{"name":"python","slug":"python","permalink":"https://www.lovelves.cn/tags/python/"},{"name":"酷我音乐爬取","slug":"酷我音乐爬取","permalink":"https://www.lovelves.cn/tags/酷我音乐爬取/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"JdbcTemplate","slug":"JdbcTemplate","date":"2021-06-14T03:33:38.000Z","updated":"2021-06-16T06:40:14.000Z","comments":true,"path":"2021/06/14/JdbcTemplate/","link":"","permalink":"https://www.lovelves.cn/2021/06/14/JdbcTemplate/","excerpt":"","text":"JdbcTemplate基本使用01-JdbcTemplate基本使用-概述(了解)JdbcTemplate是spring框架中提供的一个对象，是对原始繁琐的Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类。例如：操作关系型数据的JdbcTemplate和HibernateTemplate，操作nosql数据库的RedisTemplate，操作消息队列的JmsTemplate等等。 02-JdbcTemplate基本使用-开发步骤(理解)①导入spring-jdbc和spring-tx坐标 ②创建数据库表和实体 ③创建JdbcTemplate对象 ④执行数据库操作 03-JdbcTemplate基本使用-快速入门代码实现(应用)导入spring-jdbc和spring-tx坐标 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;itheima_spring_jdbc&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;itheima_spring_jdbc Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&#39;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 创建数据库表和实体 package com.itheima.domain; public class Account { private String name; private double money; public String getNa me() { return name; } public void setName(String name) { this.name = name; } public double getMoney() { return money; } public void setMoney(double money) { this.money = money; } @Override public String toString() { return &quot;Account{&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, money=&quot; + money + &#39;}&#39;; } } 创建JdbcTemplate对象 执行数据库操作 @Test //测试JdbcTemplate开发步骤 public void test1() throws PropertyVetoException { //创建数据源对象 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); JdbcTemplate jdbcTemplate = new JdbcTemplate(); //设置数据源对象 知道数据库在哪 jdbcTemplate.setDataSource(dataSource); //执行操作 int row = jdbcTemplate.update(&quot;insert into account values(?,?)&quot;, &quot;tom&quot;, 5000); System.out.println(row); } 04-JdbcTemplate基本使用-spring产生模板对象分析(理解)我们可以将JdbcTemplate的创建权交给Spring，将数据源DataSource的创建权也交给Spring，在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中,然后通过Spring容器获得JdbcTemplate对象来执行操作。 05-JdbcTemplate基本使用-spring产生模板对象代码实现(应用)配置如下： &lt;!--数据源对象--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///test&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--jdbc模板对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 测试代码 @Test //测试Spring产生jdbcTemplate对象 public void test2() throws PropertyVetoException { ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class); int row = jdbcTemplate.update(&quot;insert into account values(?,?)&quot;, &quot;lisi&quot;, 5000); System.out.println(row); } 06-JdbcTemplate基本使用-spring产生模板对象代码实现（抽取jdbc.properties）(应用)将数据库的连接信息抽取到外部配置文件中，和spring的配置文件分离开，有利于后期维护 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/test jdbc.username=root jdbc.password=root 配置文件修改为: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd &quot;&gt; &lt;!--加载jdbc.properties--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--数据源对象--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/bean&gt; &lt;!--jdbc模板对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 07-JdbcTemplate基本使用-常用操作-更新操作(应用)package com.itheima.test; import com.itheima.domain.Account; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import java.util.List; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class JdbcTemplateCRUDTest { @Autowired private JdbcTemplate jdbcTemplate; //修改更新 @Test public void testUpdate(){ jdbcTemplate.update(&quot;update account set money=? where name=?&quot;,10000,&quot;tom&quot;); } //删除 @Test public void testDelete(){ jdbcTemplate.update(&quot;delete from account where name=?&quot;,&quot;tom&quot;); } } 08-JdbcTemplate基本使用-常用操作-查询操作(应用)package com.itheima.test; import com.itheima.domain.Account; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import java.util.List; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class JdbcTemplateCRUDTest { @Autowired private JdbcTemplate jdbcTemplate; //聚合查询 @Test public void testQueryCount(){ Long count = jdbcTemplate.queryForObject(&quot;select count(*) from account&quot;, Long.class); System.out.println(count); } //查询一个 @Test public void testQueryOne(){ Account account = jdbcTemplate.queryForObject(&quot;select * from account where name=?&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class), &quot;tom&quot;); System.out.println(account); } //查询所有 @Test public void testQueryAll(){ List&lt;Account&gt; accountList = jdbcTemplate.query(&quot;select * from account&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); System.out.println(accountList); } } 09-JdbcTemplate基本使用-知识要点(理解，记忆)①导入spring-jdbc和spring-tx坐标 ②创建数据库表和实体 ③创建JdbcTemplate对象 JdbcTemplate jdbcTemplate = newJdbcTemplate(); jdbcTemplate.setDataSource(dataSource); ④执行数据库操作 更新操作： jdbcTemplate.update (sql,params) 查询操作： jdbcTemplate.query (sql,Mapper,params) jdbcTemplate.queryForObject(sql,Mapper,params) 声明式事务控制1. 编程式事务控制相关对象1.1 PlatformTransactionManagerPlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。 注意： PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如：Dao 层技术是jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager Dao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager 1.2 TransactionDefinitionTransactionDefinition 是事务的定义信息对象，里面有如下方法： 1. 事务隔离级别设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED ISOLATION_READ_COMMITTED ISOLATION_REPEATABLE_READ ISOLATION_SERIALIZABLE 2. 事务传播行为 REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER：以非事务方式运行，如果当前存在事务，抛出异常 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作 超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置 是否只读：建议查询时设置为只读 1.3 TransactionStatusTransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。 1.4 知识要点编程式事务控制三大对象 PlatformTransactionManager TransactionDefinition TransactionStatus 2 基于 XML 的声明式事务控制2.1 什么是声明式事务控制Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。 声明式事务处理的作用 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便 注意：Spring 声明式事务控制底层就是AOP。 2.2 声明式事务控制的实现声明式事务控制明确事项： 谁是切点？ 谁是通知？ 配置切面？ ①引入tx命名空间 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; ②配置事务增强 &lt;!--平台事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--事务增强配置--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; ③配置事务 AOP 织入 &lt;!--事务的aop增强--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; ④测试事务控制转账业务代码 @Override public void transfer(String outMan, String inMan, double money) { accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money); } 2.3 切点方法的事务参数的配置&lt;!--事务增强配置--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 其中，tx:method 代表切点方法的事务参数的配置，例如： &lt;tx:method name=&quot;transfer&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; timeout=&quot;-1&quot; read-only=&quot;false&quot;/&gt; name：切点方法名称 isolation:事务的隔离级别 propogation：事务的传播行为 timeout：超时时间 read-only：是否只读 2.4 知识要点声明式事务控制的配置要点 平台事务管理器配置 事务通知的配置 事务aop织入的配置 3 基于注解的声明式事务控制3.1 使用注解配置声明式事务控制 编写 AccoutDao @Repository(&quot;accountDao&quot;) public class AccountDaoImpl implements AccountDao { @Autowired private JdbcTemplate jdbcTemplate; public void out(String outMan, double money) { jdbcTemplate.update(&quot;update account set money=money-? where name=?&quot;,money,outMan); } public void in(String inMan, double money) { jdbcTemplate.update(&quot;update account set money=money+? where name=?&quot;,money,inMan); } } 编写 AccoutService @Service(&quot;accountService&quot;) @Transactional public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED) public void transfer(String outMan, String inMan, double money) { accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money); } } 编写 applicationContext.xml 配置文件 &lt;!—之前省略datsSource、jdbcTemplate、平台事务管理器的配置--&gt; &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt; &lt;!--事务的注解驱动--&gt; &lt;tx:annotation-driven/&gt; 3.2 注解配置声明式事务控制解析①使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。 ②注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。 ③使用在方法上，不同的方法可以采用不同的事务参数配置。 ④Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven /&gt; 3.3 知识要点注解声明式事务控制的配置要点 平台事务管理器配置（xml方式） 事务通知的配置（@Transactional注解配置） 事务注解驱动的配置 tx:annotation-driven/","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.lovelves.cn/tags/springboot/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"spring学习之旅03","slug":"AOP","date":"2021-06-14T01:42:14.000Z","updated":"2021-06-20T13:37:04.759Z","comments":true,"path":"2021/06/14/AOP/","link":"","permalink":"https://www.lovelves.cn/2021/06/14/AOP/","excerpt":"","text":"1.Spring 的 AOP 简介1.1 什么是 AOPAOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 1.2 AOP 的作用及其优势作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 1.3 AOP 的底层实现实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 1.4 AOP 的动态代理技术常用的动态代理技术 JDK 代理 : 基于接口的动态代理技术 cglib 代理：基于父类的动态代理技术 1.5 JDK 的动态代理①目标类接口 public interface TargetInterface { public void method(); } ②目标类 public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); } } ③动态代理代码 Target target = new Target(); //创建目标对象 //创建代理对象 TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(target.getClass() .getClassLoader(),target.getClass().getInterfaces(),new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;前置增强代码...&quot;); Object invoke = method.invoke(target, args); System.out.println(&quot;后置增强代码...&quot;); return invoke; } } ); ④ 调用代理对象的方法测试 // 测试,当调用接口的任何方法时，代理对象的代码都无序修改 proxy.method(); 1.6 cglib 的动态代理①目标类 public class Target { public void method() { System.out.println(&quot;Target running....&quot;); } } ②动态代理代码 Target target = new Target(); //创建目标对象 Enhancer enhancer = new Enhancer(); //创建增强器 enhancer.setSuperclass(Target.class); //设置父类 enhancer.setCallback(new MethodInterceptor() { //设置回调 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(&quot;前置代码增强....&quot;); Object invoke = method.invoke(target, objects); System.out.println(&quot;后置代码增强....&quot;); return invoke; } }); Target proxy = (Target) enhancer.create(); //创建代理对象 ③调用代理对象的方法测试 //测试,当调用接口的任何方法时，代理对象的代码都无序修改 proxy.method(); 1.7 AOP 相关概念Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。 在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下： Target（目标对象）：代理的目标对象 Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点 Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义 Advice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知 Aspect（切面）：是切入点和通知（引介）的结合 Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入 1.8 AOP 开发明确的事项 1.8 AOP 开发明确的事项 1.8 AOP 开发明确的事项1)需要编写的内容 编写核心业务代码（目标类的目标方法） 编写切面类，切面类中有通知(增强功能方法) 在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合 2）AOP 技术实现的内容Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 3）AOP 底层使用哪种代理方式在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 1.9 知识要点 aop：面向切面编程 aop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理 aop的重点概念： Pointcut（切入点）：被增强的方法 Advice（通知/ 增强）：封装增强业务逻辑的方法 Aspect（切面）：切点+通知 Weaving（织入）：将切点与通知结合的过程 开发明确事项： 谁是切点（切点表达式配置） 谁是通知（切面类中的增强方法） 将切点和通知进行织入配置 2. 基于 XML 的 AOP 开发2.1 快速入门①导入 AOP 相关坐标 ②创建目标接口和目标类（内部有切点） ③创建切面类（内部有增强方法） ④将目标类和切面类的对象创建权交给 spring ⑤在 applicationContext.xml 中配置织入关系 ⑥测试代码 ①导入 AOP 相关坐标 &lt;!--导入spring的context坐标，context依赖aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aspectj的织入 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; ②创建目标接口和目标类（内部有切点） public interface TargetInterface { public void method(); } public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); } } ③创建切面类（内部有增强方法） public class MyAspect { //前置增强方法 public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } } ④将目标类和切面类的对象创建权交给 spring &lt;!--配置目标类--&gt; &lt;bean id=&quot;target&quot; class=&quot;com.itheima.aop.Target&quot;&gt;&lt;/bean&gt; &lt;!--配置切面类--&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;com.itheima.aop.MyAspect&quot;&gt;&lt;/bean&gt; ⑤在 applicationContext.xml 中配置织入关系 导入aop命名空间 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; ⑤在 applicationContext.xml 中配置织入关系 配置切点表达式和前置增强的织入关系 &lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(public void com.itheima.aop.Target.method())&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; ⑥测试代码 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class AopTest { @Autowired private TargetInterface target; @Test public void test1(){ target.method(); } } ⑦测试结果 2.2 XML 配置 AOP 详解1) 切点表达式的写法表达式语法： execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号* 代表任意 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表 例如： execution(public void com.itheima.aop.Target.method()) execution(void com.itheima.aop.Target.*(..)) execution(* com.itheima.aop.*.*(..)) execution(* com.itheima.aop..*.*(..)) execution(* *..*.*(..)) 2) 通知的类型通知的配置语法： &lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式&quot;&gt;&lt;/aop:通知类型&gt; 3) 切点表达式的抽取当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。 &lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.itheima.aop.*.*(..))&quot;/&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 2.3 知识要点 aop织入的配置 &lt;aop:config&gt; &lt;aop:aspect ref=“切面类”&gt; &lt;aop:before method=“通知方法名称” pointcut=“切点表达式&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知 切点表达式的写法： execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 3.基于注解的 AOP 开发3.1 快速入门基于注解的aop开发步骤： ①创建目标接口和目标类（内部有切点） ②创建切面类（内部有增强方法） ③将目标类和切面类的对象创建权交给 spring ④在切面类中使用注解配置织入关系 ⑤在配置文件中开启组件扫描和 AOP 的自动代理 ⑥测试 ①创建目标接口和目标类（内部有切点） public interface TargetInterface { public void method(); } public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); } } ②创建切面类（内部有增强方法) public class MyAspect { //前置增强方法 public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } } ③将目标类和切面类的对象创建权交给 spring @Component(&quot;target&quot;) public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); } } @Component(&quot;myAspect&quot;) public class MyAspect { public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } } ④在切面类中使用注解配置织入关系 @Component(&quot;myAspect&quot;) @Aspect public class MyAspect { @Before(&quot;execution(* com.itheima.aop.*.*(..))&quot;) public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } } ⑤在配置文件中开启组件扫描和 AOP 的自动代理 &lt;!--组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.itheima.aop&quot;/&gt; &lt;!--aop的自动代理--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; ⑥测试代码 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class AopTest { @Autowired private TargetInterface target; @Test public void test1(){ target.method(); } } ⑦测试结果 3.2 注解配置 AOP 详解1) 注解通知的类型通知的配置语法：@通知注解(“切点表达式”) 2) 切点表达式的抽取同 xml配置aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下： @@Component(&quot;myAspect&quot;) @Aspect public class MyAspect { @Before(&quot;MyAspect.myPoint()&quot;) public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } @Pointcut(&quot;execution(* com.itheima.aop.*.*(..))&quot;) public void myPoint(){} } 3.3 知识要点 注解aop开发步骤 ①使用@Aspect标注切面类 ②使用@通知注解标注通知方法 ③在配置文件中配置aop自动代理aop:aspectj-autoproxy/ 3.4 环绕通知 问题：当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 分析：通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。解决：Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 spring中的环绕通知： 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 public Object aroundPringLog(ProceedingJoinPoint pjp){ Object rtValue = null; try{ Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。前置&quot;); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。后置&quot;); return rtValue; }catch (Throwable t){ System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。异常&quot;); throw new RuntimeException(t); }finally { System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。最终&quot;); } } 配置文件 &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容 此标签写在aop:aspect标签内部只能当前切面使用。 它还可以写在aop:aspect外面，此时就变成了所有切面可用 --&gt; &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt; &lt;!--配置切面 --&gt; &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt; &lt;!-- 配置环绕通知 详细的注释请看Logger类中--&gt; &lt;aop:around method=&quot;aroundPringLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 注解配置方法 public class Logger { @Pointcut(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;) private void pt1(){} @Around(&quot;pt1()&quot;) public Object aroundPringLog(ProceedingJoinPoint pjp){ Object rtValue = null; try{ Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。前置&quot;); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。后置&quot;); return rtValue; }catch (Throwable t){ System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。异常&quot;); throw new RuntimeException(t); }finally { System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。最终&quot;); } } }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.lovelves.cn/tags/spring/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"spring学习之旅02","slug":"02-SpringIoC和DI注解开发","date":"2021-06-14T01:42:14.000Z","updated":"2021-06-19T13:23:19.509Z","comments":true,"path":"2021/06/14/02-SpringIoC和DI注解开发/","link":"","permalink":"https://www.lovelves.cn/2021/06/14/02-SpringIoC和DI注解开发/","excerpt":"","text":"1.Spring配置数据源(利用spring来配置数据库的连接池 )1.1 数据源（连接池）的作用数据源(连接池)是提高程序性能如出现的 事先实例化数据源，初始化部分连接资源 使用连接资源时从数据源中获取 使用完毕后将连接资源归还给数据源 常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等 开发步骤 ①导入数据源的坐标和数据库驱动坐标 ②创建数据源对象 ③设置数据源的基本连接数据 ④使用数据源获取连接资源和归还连接资源 1.2 数据源的手动创建①导入c3p0和druid的坐标 &lt;!-- C3P0连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Druid连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; ①导入mysql数据库驱动坐标 &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt; &lt;/dependency&gt; ②创建C3P0连接池 @Test public void testC3P0() throws Exception { //创建数据源 ComboPooledDataSource dataSource = new ComboPooledDataSource(); //设置数据库连接参数 dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection); } ②创建Druid连接池 @Test public void testDruid() throws Exception { //创建数据源 DruidDataSource dataSource = new DruidDataSource(); //设置数据库连接参数 dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection); } ③提取jdbc.properties配置文件 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/test jdbc.username=root jdbc.password=root ④读取jdbc.properties配置文件创建连接池 @Test public void testC3P0ByProperties() throws Exception { //加载类路径下的jdbc.properties ResourceBundle rb = ResourceBundle.getBundle(&quot;jdbc&quot;); ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(rb.getString(&quot;jdbc.driver&quot;)); dataSource.setJdbcUrl(rb.getString(&quot;jdbc.url&quot;)); dataSource.setUser(rb.getString(&quot;jdbc.username&quot;)); dataSource.setPassword(rb.getString(&quot;jdbc.password&quot;)); Connection connection = dataSource.getConnection(); System.out.println(connection); } 1.3 Spring配置数据源可以将DataSource的创建权交由Spring容器去完成 DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的 DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入 &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; 测试从容器当中获取数据源 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DataSource dataSource = (DataSource) applicationContext.getBean(&quot;dataSource&quot;); Connection connection = dataSource.getConnection(); System.out.println(connection); 1.4 抽取jdbc配置文件applicationContext.xml加载jdbc.properties配置文件获得连接信息。 首先，需要引入context命名空间和约束路径： 命名空间：xmlns:context=”http://www.springframework.org/schema/context&quot; 约束路径：http://www.springframework.org/schema/context​ ​ http://www.springframework.org/schema/context/spring-context.xsd &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/bean&gt; 1.5 知识要点Spring容器加载properties文件 &lt;context:property-placeholder location=&quot;xx.properties&quot;/&gt; &lt;property name=&quot;&quot; value=&quot;${key}&quot;/&gt; 2. Spring注解开发2.1 Spring原始注解Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。 Spring原始注解主要是替代的配置 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 用于创建对象的 他们的作用就和在XML配置文件中编写一个标签实现的功能是一样的 Component: 作用：用于把当前类对象存入spring容器中 属性：value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。 Controller：一般用在表现层 Service：一般用在业务层 Repository：一般用在持久层 以上三个注解他们的作用和属性与Component是一模一样。 他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰 注意： 使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。 &lt;!--注解的组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt; 使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。也可以使用使用@Compont或@Service标识UserServiceImpl需要Spring进行实例化 //@Component(&quot;userDao&quot;) @Repository(&quot;userDao&quot;) public class UserDaoImpl implements UserDao { @Override public void save() { System.out.println(&quot;save running... ...&quot;); } } 用于注入数据的 他们的作用就和在xml配置文件中的bean标签中写一个标签的作用是一样的 Autowired: 作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功 如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。 如果Ioc容器中有多个类型匹配时： 出现位置： 可以是变量上，也可以是方法上 细节： 在使用注解注入时，set方法就不是必须的了。 Qualifier: 作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以 属性： value：用于指定注入bean的id。 Resource 作用：直接按照bean的id注入。它可以独立使用 属性： name：用于指定bean的id。 以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。 另外，集合类型的注入只能通过XML来实现。* Value 作用：用于注入基本类型和String类型的数据 属性： value：用于指定数据的值。它可以使用spring中SpEL(也就是spring的el表达式） SpEL的写法：${表达式}使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入 //@Component(&quot;userService&quot;) @Service(&quot;userService&quot;) public class UserServiceImpl implements UserService { /*@Autowired @Qualifier(&quot;userDao&quot;)*/ @Resource(name=&quot;userDao&quot;) private UserDao userDao; @Override public void save() { userDao.save(); } } 使用@Value进行字符串的注入 @Repository(&quot;userDao&quot;) public class UserDaoImpl implements UserDao { @Value(&quot;注入普通数据&quot;) private String str; @Value(&quot;${jdbc.driver}&quot;) private String driver; @Override public void save() { System.out.println(str); System.out.println(driver); System.out.println(&quot;save running... ...&quot;); } } * 用于改变作用范围的 他们的作用就和在bean标签中使用scope属性实现的功能是一样的 Scope 作用：用于指定bean的作用范围 属性： value：指定范围的取值。常用取值：singleton prototype* 和生命周期相关 了解 他们的作用就和在bean标签中使用init-method和destroy-methode的作用是一样的 PreDestroy 作用：用于指定销毁方法 PostConstruct 作用：用于指定初始化方法 使用@Scope标注Bean的范围 //@Scope(&quot;prototype&quot;) @Scope(&quot;singleton&quot;) public class UserDaoImpl implements UserDao { //此处省略代码 } 使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法 @PostConstruct public void init(){ System.out.println(&quot;初始化方法....&quot;); } @PreDestroy public void destroy(){ System.out.println(&quot;销毁方法.....&quot;); } 2.2 Spring新注解 Configuration 作用：指定当前类是一个配置类 细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。 ComponentScan 作用：用于通过注解指定spring在创建容器时要扫描的包 属性： value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包。 我们使用此注解就等同于在xml中配置了: &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt; Bean 作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中 属性: name:用于指定bean的id。当不写时，默认值是当前方法的名称 细节： 当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。 查找的方式和Autowired注解的作用是一样的 Import 作用：用于导入其他的配置类 属性： value：用于指定其他配置类的字节码。 当我们使用Import的注解之后，有Import注解的类就父配置类，而导入的都是子配置类 PropertySource 作用：用于指定properties文件的位置 属性： value：指定文件的名称和路径。 关键字：classpath，表示类路径下 @Configuration @ComponentScan @Import @Configuration @ComponentScan(&quot;com.itheima&quot;) @Import({DataSourceConfiguration.class}) public class SpringConfiguration { } @PropertySource @value @PropertySource(&quot;classpath:jdbc.properties&quot;) public class DataSourceConfiguration { @Value(&quot;${jdbc.driver}&quot;) private String driver; @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String username; @Value(&quot;${jdbc.password}&quot;) private String password; @Bean @Bean(name=&quot;dataSource&quot;) public DataSource getDataSource() throws PropertyVetoException { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource; } 测试加载核心配置类创建Spring容器 @Test public void testAnnoConfiguration() throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfiguration.class); UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;); userService.save(); DataSource dataSource = (DataSource) applicationContext.getBean(&quot;dataSource&quot;); Connection connection = dataSource.getConnection(); System.out.println(connection); } 3. Spring整合Junit3.1 原始Junit测试Spring的问题在测试类中，每个测试方法都有以下两行代码： ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class); 这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。 3.2 上述问题解决思路让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它 将需要进行测试Bean直接在测试类中进行注入 3.3 Spring集成Junit步骤①导入spring集成Junit的坐标 ②使用@Runwith注解替换原来的运行期 ③使用@ContextConfiguration指定配置文件或配置类 ④使用@Autowired注入需要测试的对象 ⑤创建测试方法进行测试 3.4 Spring集成Junit代码实现①导入spring集成Junit的坐标 &lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; ②使用@Runwith注解替换原来的运行期 @RunWith(SpringJUnit4ClassRunner.class) public class SpringJunitTest { } ③使用@ContextConfiguration指定配置文件或配置类 @RunWith(SpringJUnit4ClassRunner.class) //加载spring核心配置文件 //@ContextConfiguration(value = {&quot;classpath:applicationContext.xml&quot;}) //加载spring核心配置类 @ContextConfiguration(classes = {SpringConfiguration.class}) public class SpringJunitTest { } ④使用@Autowired注入需要测试的对象 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = {SpringConfiguration.class}) public class SpringJunitTest { @Autowired private UserService userService; } ⑤创建测试方法进行测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = {SpringConfiguration.class})public class SpringJunitTest { @Autowired private UserService userService; @Test public void testUserService(){ userService.save(); } } 可以用git下载相关代码 git clone https://gitee.com/lovelves/learning-code-warehouse.git","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.lovelves.cn/tags/spring/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"hexo的安装使用","slug":"hexo","date":"2021-06-14T01:42:14.000Z","updated":"2021-06-20T13:37:00.746Z","comments":true,"path":"2021/06/14/hexo/","link":"","permalink":"https://www.lovelves.cn/2021/06/14/hexo/","excerpt":"","text":"hexo安装及使用安装前必备环境大前提是要安装nodejs 和gitgit的下载地址 https://git-scm.com/downloads （git安装对应的版本就可以了 安装好简单 这就不叙述了）node下载地址 https://nodejs.org/dist/由于每个人的电脑环境是不一样的 打开这个网站选择自己电脑适合的版本下载msi 后序结尾的是windows版本，pkg结尾的是mac版本 ，zip结尾的是绿色版gz结尾的事linux版本 安装很简单 下一步下一步完成就可以了 就是绿色版比较麻烦 需要自己配置环境变量 建议选择12版本 不高不低 高版本只支持win10安装后的第一件事给npm 换源由于国内网络环境 只能换源才能提高速度使用npm 淘宝镜像（http://npm.taobao.org/）可在cmd命令窗口执行： npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完后 以后用cnpm 来代替npm以上都安装好后可以 安装hexo了 安装hexo在cmd命令窗口执行以下命令 cnpm install hexo-cli -g hexo 使用方法生成hexo 官方的简单主题初始化生成hexo相关文件在命令行窗口输入以下命令 mkdir hello hexo init 在hello文件中会生成以下目录 生成静态页面在命令行窗口输入以下命令 hexo g 运行服务 hexo s 访问浏览 http://localhost:4000一个简单的博客网站就搭建完成了。挺简单的 网站中的相关目录详细介绍_config.yml 配置文件 配置站点相关信息 # Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site 网站相关信息 title: Hexo. # 网站标题 subtitle: &#39;&#39; description: &#39;&#39; keywords: author: John Doe #作者 language: en timezone: &#39;&#39; # URL ## Set your site url here. For example, if you use GitHub Page, set url as &#39;https://username.github.io/project&#39; url: http://example.com # 部署的网站地址 permalink: :year/:month/:day/:title/ permalink_defaults: pretty_urls: trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks # Directory source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: enable: true # Open external links in new tab field: site # Apply to the whole site exclude: &#39;&#39; filename_case: 0 render_drafts: false post_asset_folder: false # 建议为ture。 relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: &#39;&#39; wrap: true hljs: false prismjs: enable: false preprocess: true line_number: true tab_replace: &#39;&#39; # Home page setting # path: Root path for your blogs index page. (default = &#39;&#39;) # per_page: Posts displayed per page. (0 = disable pagination) # order_by: Posts order. (Order by date descending by default) index_generator: path: &#39;&#39; per_page: 10 order_by: -date # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Metadata elements ## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta meta_generator: true # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss ## updated_option supports &#39;mtime&#39;, &#39;date&#39;, &#39;empty&#39; updated_option: &#39;mtime&#39; # Pagination ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page # Include / Exclude file(s) ## include:/exclude: options only apply to the &#39;source/&#39; folder include: exclude: ignore: # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: landscape #修改主题 # Deployment ## Docs: https://hexo.io/docs/one-command-deployment deploy: type: &#39;&#39; 配置文件比较重要的属性theme 属性 网上下载主题后放到根目录的themes文件夹中 然后把主题名字写到这里比如 我用的是Sakura 主题在配置文件中修改为 post_asset_folder 属性这个属性为 true 方便文章中插入图片 当你新建文章时 会自动生成文章对应的文件夹用于存放图片然后在文章中用 {% asset_img 图片1.jpg 图片描述 %} 插入图片 图片路径引用文章对应的文件夹如果想用回md插入图片语法 可以在配置文件这样配置 post_asset_folder: true marked: prependRoot: true postAsset: true 这样配置后 md中插入图片就简单了 直接写图片的名字如 ![](图片.png) deploy 属性定义部署的git地址以github为例 deploy: type: git repo: # github: git@github.com:honjun/honjun.github.io.git # github: https://github.com/honjun/honjun.github.io.git coding: git@github.com:lingdas/lingdas.github.io.git branch: master public 程序生成的静态页面 但你执行 hexo g 的时候 会生成themes 存放主题的地方 主题放好了记得在_config.yml 中修改theme属性scaffolds 模版 当你执行命令 hexo n 时候 它默认生成 _post中的模版source 最重要的一个文件 放你的文章 其他文件可以丢 这个文件可不能丢 都是你的心血 日常经常使用的hexo命令清除已生成的静态文件这个步骤是 配置文件发生变化 或在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 hexo clean 生成静态文件 当新增文章 文章变动时使用它 hexo g 运行服务 在本地运行网站 hexo s 新建文章 hexo n 文章标题 会在 source中的_posts中生成一个md文件 文章头部分 定义标题 图片 描述等等 如 --- title: AOP date: 2021-06-14 09:42:14 author: lovelves avatar: https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1441836571,2166773131&amp;fm=26&amp;gp=0.jpg authorLink: authorAbout: 一个好奇的人 authorDesc: 一个好奇的人 categories: 技术 comments: true tags: springboot keywords: aop description: photos: https://cdn.jsdelivr.net/gh/lingdas/note/img/6.jpg --- 以上这段每个文章必须带上 可以通过修改scaffolds/post_md 来定义每次新增的文章格式 部署命令 hexo d 一键部署 hexo clean &amp;&amp; hexo g -d 小提示 部署到github前 要安装此插件 否则部署不成功 cnpm install hexo-deployer-git --save 看完以上 建议去官方https://hexo.io/zh-cn/docs/ 看看 加强印象 小技巧用github做图床 访问的时候用这个链接加速https://cdn.jsdelivr.net/gh/github的名字/项目名字/具体图片路径 如下面 我的名字是lingdas 项目是note 具体路径 /img/7.jpg https://cdn.jsdelivr.net/gh/lingdas/note/img/7.jpg 安装看版娘cnpm install --save hexo-helper-live2d 模型下载 cnpm install live2d-widget-model-tsumiki 模型列表 live2d-widget-model-chitose live2d-widget-model-epsilon2_1 live2d-widget-model-gf live2d-widget-model-haru/01 live2d-widget-model-haru/02 live2d-widget-model-haruto live2d-widget-model-hibiki live2d-widget-model-hijiki live2d-widget-model-izumi live2d-widget-model-koharu live2d-widget-model-miku live2d-widget-model-ni-j live2d-widget-model-nico live2d-widget-model-nietzsche live2d-widget-model-nipsilon live2d-widget-model-nito live2d-widget-model-shizuku live2d-widget-model-tororo live2d-widget-model-tsumiki live2d-widget-model-unitychan live2d-widget-model-wanko live2d-widget-model-z16 模型配置（在根目录_config.yml后面加上这个配置） # Live2D ## https://github.com/EYHN/hexo-helper-live2d live2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-haru # 你下载的模型名字 scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 # use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url display: superSample: 2 width: 280 height: 480 position: right hOffset: 0 vOffset: -20 mobile: show: true # 是否在移动设备上显示 scale: 0.5 # 移动设备上的缩放 react: opacityDefault: 0.7 opacityOnHover: 0.8 在我们的Hexo根目录下新建一个live2d_models文件夹，注意：文件夹必须为该名字把下载的模型复制到这个文件夹中 live2d_models比如我下载了这个模型 在node_modules 中 把上文件复制到刚创建的文件夹中比如 我想用 Bronya这个模型 我就修改配置中的 model: use: live2d-widget-model-haru # 这里修改为Bronya scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 加强版看板娘如果已经安装过官方提供的live2d，需要先卸载！ cnpm uninstall hexo-helper-live2d 经过张书樵大神魔改后的项目下载地址：https://github.com/stevenjoezhang/live2d-widget把项目文件下载解压到：themes\\主题名字\\source\\文件夹下打开项目目录进入修改autoload.js文件，将live2d_path设为自己的路径，一般没什么太大变化都为：/live2d-widget/然后在 header 模版的header中中引入 &lt;!--自定义看板娘--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;/&gt; 这样就可以了看到效果了","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.lovelves.cn/tags/hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"Spring学习之旅-01","slug":"springboot笔记","date":"2021-06-14T00:46:12.000Z","updated":"2021-06-19T13:22:57.786Z","comments":true,"path":"2021/06/14/springboot笔记/","link":"","permalink":"https://www.lovelves.cn/2021/06/14/springboot笔记/","excerpt":"","text":"1. spring概述1.1 Spring是什么（理解）Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。 提供了展现层 SpringMVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架 1.2 Spring发展历程 （了解）Rod Johnson （ Spring 之父） 2017 年9 月份发布了 Spring 的最新版本 Spring5.0通用版（GA） 1.3 Spring的优势（理解）方便解耦，简化开发 AOP 编程的支持 声明式事务的支持 方便程序的测试 1.4 Spring的体系结构（了解） 2. spring快速入门2.1 Spring程序开发步骤①导入 Spring 开发的基本包坐标 ②编写 Dao 接口和实现类 ③创建 Spring 核心配置文件 ④在 Spring 配置文件中配置 UserDaoImpl ⑤使用 Spring 的 API 获得 Bean 实例 2.2 导入Spring开发的基本包坐标 单元测试&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;spring_01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!-- junit的版本有3.x, 4.x, 5.x 5.x还没有发布, 现在都用是4.x --&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 2.3 编写Dao接口和实现类public interface UserDao { public void save(); } public class UserDaoImpl implements UserDao { @Override public void save() { System.out.println(&quot;UserDao save method running....&quot;); } } 2.4 创建Spring核心配置文件在类路径下（resources）创建applicationContext.xml配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;/beans&gt; 2.5 在Spring配置文件中配置UserDaoImpl&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.lovelves.UserDaoimpl&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 2.6 使用Spring的API获得Bean实例@Test public void test1(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); } 3. Spring配置文件3.1 Bean标签基本配置用于配置对象交由Spring 来创建。 默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。 基本属性： id：Bean实例在Spring容器中的唯一标识 class：Bean的全限定名称 3.2 Bean标签范围配置scope:指对象的作用范围，取值如下： 取值范围 说明 singleton 默认值，单例的 prototype 多例的 request WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 request 域中 session WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 session 域中 global session WEB 项目中，应用在 Portlet 环境，如果没有 Portlet 环境那么globalSession 相当于 session 1）当scope的取值为singleton时 ​ Bean的实例化个数：1个 ​ Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例 ​ Bean的生命周期： 对象创建：当应用加载，创建容器时，对象就被创建了 对象运行：只要容器在，对象一直活着 对象销毁：当应用卸载，销毁容器时，对象就被销毁了 2）当scope的取值为prototype时 ​ Bean的实例化个数：多个 ​ Bean的实例化时机：当调用getBean()方法时实例化Bean 对象创建：当使用对象时，创建新的对象实例 对象运行：只要对象在使用中，就一直活着 对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了 3.3 Bean生命周期配置init-method：指定类中的初始化方法名称 destroy-method：指定类中销毁方法名称 3.4 Bean实例化三种方式1） 使用无参构造方法实例化 ​ 它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败 &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; 2） 工厂静态方法实例化 ​ 工厂的静态方法返回Bean实例 public class StaticFactoryBean { public static UserDao createUserDao(){ return new UserDaoImpl(); } } &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.StaticFactoryBean&quot; factory-method=&quot;createUserDao&quot; /&gt; 3） 工厂实例方法实例化 ​ 工厂的非静态方法返回Bean实例 public class DynamicFactoryBean { public UserDao createUserDao(){ return new UserDaoImpl(); } } &lt;bean id=&quot;factoryBean&quot; class=&quot;com.itheima.factory.DynamicFactoryBean&quot;/&gt; &lt;bean id=&quot;userDao&quot; factory-bean=&quot;factoryBean&quot; factory-method=&quot;createUserDao&quot;/&gt; 3.5 Bean的依赖注入入门①创建 UserService，UserService 内部在调用 UserDao的save() 方法 public class UserServiceImpl implements UserService { @Override public void save() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); } } ②将 UserServiceImpl 的创建权交给 Spring &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;/&gt; ③从 Spring 容器中获得 UserService 进行操作 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;); userService.save(); 3.6 Bean的依赖注入概念依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。 在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。 IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。 简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取 3.7 Bean的依赖注入方式①构造方法 ​ 创建有参构造 public class UserServiceImpl implements UserService { @Override public void save() { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); } } ​ 配置Spring容器调用有参构造时进行注入 &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; ②set方法 ​ 在UserServiceImpl中添加setUserDao方法 public class UserServiceImpl implements UserService { private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void save() { userDao.save(); } } ​ 配置Spring容器调用set方法进行注入 &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; set方法:P命名空间注入 ​ P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下： ​ 首先，需要引入P命名空间： xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 其次，需要修改注入方式 &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot;/&gt; 3.8 Bean的依赖注入的数据类型上面的操作，都是注入的引用Bean，处了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。 注入数据的三种数据类型 普通数据类型 引用数据类型 集合数据类型 其中引用数据类型，此处就不再赘述了，之前的操作都是对UserDao对象的引用进行注入的，下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。 Bean的依赖注入的数据类型 （1）普通数据类型的注入 public class UserDaoImpl implements UserDao { private String company; private int age; public void setCompany(String company) { this.company = company; } public void setAge(int age) { this.age = age; } public void save() { System.out.println(company+&quot;===&quot;+age); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;company&quot; value=&quot;传智播客&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;&gt;&lt;/property&gt; &lt;/bean&gt; （2）集合数据类型（List）的注入 public class UserDaoImpl implements UserDao { private List&lt;String&gt; strList; public void setStrList(List&lt;String&gt; strList) { this.strList = strList; } public void save() { System.out.println(strList); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;strList&quot;&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; （3）集合数据类型（List）的注入 public class UserDaoImpl implements UserDao { private List&lt;User&gt; userList; public void setUserList(List&lt;User&gt; userList) { this.userList = userList; } public void save() { System.out.println(userList); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;u1&quot; class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean id=&quot;u2&quot; class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;userList&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean class=&quot;com.itheima.domain.User&quot;/&gt; &lt;ref bean=&quot;u1&quot;/&gt; &lt;ref bean=&quot;u2&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; （4）集合数据类型（ Map&lt;String,User&gt; ）的注入 public class UserDaoImpl implements UserDao { private Map&lt;String,User&gt; userMap; public void setUserMap(Map&lt;String, User&gt; userMap) { this.userMap = userMap; } public void save() { System.out.println(userMap); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;u1&quot; class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean id=&quot;u2&quot; class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;userMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;user1&quot; value-ref=&quot;u1&quot;/&gt; &lt;entry key=&quot;user2&quot; value-ref=&quot;u2&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; （5）集合数据类型（Properties）的注入 public class UserDaoImpl implements UserDao { private Properties properties; public void setProperties(Properties properties) { this.properties = properties; } public void save() { System.out.println(properties); System.out.println(&quot;UserDao save method running....&quot;); } } &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;p1&quot;&gt;aaa&lt;/prop&gt; &lt;prop key=&quot;p2&quot;&gt;bbb&lt;/prop&gt; &lt;prop key=&quot;p3&quot;&gt;ccc&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 3.9 引入其他配置文件（分模块开发）实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载 &lt;import resource=&quot;applicationContext-xxx.xml&quot;/&gt; 4. spring相关API4.1 ApplicationContext的继承体系applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象 4.2 ApplicationContext的实现类1）ClassPathXmlApplicationContext ​ 它是从类的根路径下加载配置文件 推荐使用这种 2）FileSystemXmlApplicationContext ​ 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 3）AnnotationConfigApplicationContext ​ 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 4.3 getBean()方法使用public Object getBean(String name) throws BeansException { assertBeanFactoryActive(); return getBeanFactory().getBean(name); } public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException { assertBeanFactoryActive(); return getBeanFactory().getBean(requiredType); } 其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。 当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错 getBean()方法使用 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService userService1 = (UserService) applicationContext.getBean(&quot;userService&quot;); UserService userService2 = applicationContext.getBean(UserService.class); 可以用git下载相关代码 git clone https://gitee.com/lovelves/learning-code-warehouse.git","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.lovelves.cn/tags/spring/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2021-06-21T13:31:02.642Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"https://www.lovelves.cn/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.lovelves.cn/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.lovelves.cn/categories/技术/"}]}]}